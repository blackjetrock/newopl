<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0041)https://www.jaapsch.net/psion/manlzpg.htm -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>LZ/LZ64 Programming Manual - Jaap's Psion Organiser II Page</title>
<link rel="stylesheet" type="text/css" href="./LZ_LZ64 Programming Manual - Jaap&#39;s Psion Organiser II Page_files/psion.css">
<link rel="shortcut icon" href="https://www.jaapsch.net/psion/pics/favicon.ico">
<script type="application/ld+json">
{
  "@context": "http://schema.org", "@type": "BreadcrumbList",
  "itemListElement": [{
    "@type": "ListItem", "position": 1,
    "item": { "@id": "../index.htm", "name": "Home" }
  },{
    "@type": "ListItem", "position": 2,
    "item": { "@id": "index.htm", "name": "Psion II" }
  },{
    "@type": "ListItem", "position": 3,
    "item": { "@id": "manlzpg.htm", "name": "LZ Programming Manual" }
  }]
}
</script>
</head>
<body>
<div class="header"><h1>Jaap's Psion II Page</h1><a href="https://www.jaapsch.net/psion/index.htm" class="jpp"></a></div>
<ol class="breadcrumb">
  <li><a href="https://www.jaapsch.net/index.htm">Home</a> /</li>
  <li><a href="https://www.jaapsch.net/psion/index.htm">Psion II</a> /</li>
  <li>LZ Programming Manual</li>
</ol>

<p>This Psion LZ/LZ64 Programming manual is also available in <a href="https://www.jaapsch.net/psion/manlzpgf.htm">French</a>
and <a href="https://www.jaapsch.net/psion/manlzpgi.htm">Italian</a>.</p>

<hr>
<h1>LZ/LZ64 Programming Manual</h1>

<hr>

<h2>Contents</h2>

<p class="contents"><a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-1a"><b>1 Introduction to OPL</b></a>
     <a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-2a">The Prog menu</a>
     <a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-2b">Creating, saving and running a procedure</a>
     <a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-9a">Edit. Print, Dir. Copy, Delete</a>
<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-1a"><b>2 Procedures and variables</b></a>
<a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-1a"><b>3 Loops and branches</b></a>
<a href="https://www.jaapsch.net/psion/manlzpg.htm#p4-1a"><b>4 Operators</b></a>
<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-1a"><b>5 Handling data files</b></a>
<a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a"><b>6 Handling any type of file</b></a>
<a href="https://www.jaapsch.net/psion/manlzpg.htm#p7-1a"><b>7 Error handling</b></a>
     <a href="https://www.jaapsch.net/psion/manlzpg.htm#p7-1a">Common errors</a>
     <a href="https://www.jaapsch.net/psion/manlzpg.htm#p7-4a">Run-time errors</a>
     <a href="https://www.jaapsch.net/psion/manlzpg.htm#p7-4b">Error trapping</a>
<a href="https://www.jaapsch.net/psion/manlzpg.htm#p8-1a"><b>8 Example programs</b></a>
<a href="https://www.jaapsch.net/psion/manlzpg.htm#p9-1a"><b>9 OPL commands and functions</b></a>
     <a href="https://www.jaapsch.net/psion/manlzpg.htm#p9-1b">Summary</a>
     <a href="https://www.jaapsch.net/psion/manlzpg.htm#p9-6a">Command syntax</a>
     <a href="https://www.jaapsch.net/psion/manlzpg.htm#p9-7a">Function syntax</a>
     <a href="https://www.jaapsch.net/psion/manlzpg.htm#p9-8a">List of commands and functions</a></p>
<p class="contents"><b>Appendices</b>
<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-1a"><b>A Organiser character set</b></a>
     <a href="https://www.jaapsch.net/psion/manlzpg.htm#A-1b">Printing non-keyboard characters</a>
     <a href="https://www.jaapsch.net/psion/manlzpg.htm#A-4a">Codes for special keys</a>
     <a href="https://www.jaapsch.net/psion/manlzpg.htm#A-5">Control characters</a>
     <a href="https://www.jaapsch.net/psion/manlzpg.htm#A-6">User-defined characters</a>
<a href="https://www.jaapsch.net/psion/manlzpg.htm#B-1"><b>B Technical Data</b></a>
<a href="https://www.jaapsch.net/psion/manlzpg.htm#C-1"><b>C Technical programming</b></a>
     <a href="https://www.jaapsch.net/psion/manlzpg.htm#C-1">Memory addresses</a>
<a href="https://www.jaapsch.net/psion/manlzpg.htm#D-1"><b>D Error messages</b></a>
</p>

<hr>

<a id="p1-1a"></a><h2>1 Introduction to OPL</h2>

<p>OPL is the Organiser Programming Language. It has a set of
commands and functions suitable for all kinds of applications -
including the manipulation of records in data files.

</p><p>To enter OPL:
</p><ul><li type="square"> Select Prog from the main menu, by pressing P.</li></ul>

<p>From the Prog menu you can start new programs or continue
with old ones.

</p><p>Once you have written programs in OPL, you can run them from
within Prog or directly from the main menu, or even whilst you are
working on the calculator or the Pocket Spreadsheet.

</p><p>An OPL program consists of one or more <b>procedures</b> each of which
is typed in separately. A simple program may consist of just one
and a more complex program of a main procedure which calls others.

</p><p>The most efficient way to use OPL is to write short procedures
which can be tested individually. Each one should ideally perform
just one specific task. That way, programs which have similar
requirements can share one common procedure to do the same job.

</p><p><b>This chapter shows you how to write, save and run a simple
procedure and covers all the options on the Prog menu.</b>


<a id="p1-2a"></a></p><h3>The Prog menu</h3>

<p>The Prog menu looks like this:
</p><p><span class="screen"><u>              11:32a</u>
Edit   New    Run  &nbsp;
Print  Dir    Copy &nbsp;
Delete              </span>

</p><p>The options on the Prog menu are:

</p><table summary="Prog Menu Options">
<tbody><tr><td><b>Edit</b></td><td>Lets you alter an existing procedure.</td></tr>
<tr><td><b>New</b></td><td>Lets you type in and save a new procedure.</td></tr>
<tr><td><b>Run</b></td><td>Executes an existing procedure.</td></tr>
<tr><td><b>Print</b></td><td>Prints out a procedure on an attached printer or computer.</td></tr>
<tr><td><b>Dir</b></td><td>Provides a directory list of your procedures.</td></tr>
<tr><td><b>Copy</b></td><td>Copies procedures to another device.</td></tr>
<tr><td><b>Delete</b></td><td>Deletes procedures.</td></tr>
</tbody></table>


<a id="p1-2b"></a><h3>Creating, saving and running a procedure</h3>

<p>The simple procedure below just clears the screen and
displays the date until you press a key. The procedure's
name is DATE:

</p><p class="program">DATE:
CLS
PRINT "TODAY IS",DAY;"/";MONTH
GET</p>

<a id="p1-3a"></a><h3>1 Creating a new procedure</h3>

<ul><li>Select <b>New</b> from the menu and the screen shows:
<br><span class="screen">New A:_             </span>
</li></ul>

<p>The current device is shown after the word New; in this
case it is A: (the internal memory). If you want to work
on a pack, press <b>MODE</b> to change device.

</p><p>The first thing to type is the procedure name, this can
be up to 8 characters long and must start with a letter.
</p><ul><li type="square"> Type in DATE as the name for your first
procedure. <b>(Don't type the colon.)</b> Press <b>EXE</b>.</li></ul>

<p>The procedure name is shown with a colon at the end. The
cursor is flashing at the end of it.
<br><span class="screen">DATE:_              </span>

</p><ul><li type="square"> Press <b>EXE</b> to move the cursor down to the next line and
      you can begin typing. Typing in the OPL editor is the
      same as typing in the notepad.</li></ul>

<p>If you are not used to the keys look at the Keyboard section
in Chapter 2 of the operating manual.

</p><p><b>Note: in OPL you can use either upper case or lower case
letters in any combination.</b>

<a id="p1-3b"></a></p><ul><li type="square"> Type the first line:<br>
<span class="code">CLS</span></li>
    <li type="square"> This is a <b>command</b>. When you run the procedure, CLS is an
      instruction to OPL to clear the screen.</li>
    <li type="square"> Press <b>EXE</b> to start a new line, then type:<br>
          <span class="code">PRINT "TODAY IS",DAY;"/";MONTH</span></li>
</ul>

<p>Check that the line appear on screen exactly as it does here as
even the spaces are important. Here is an analysis of the line:

</p><ul>
  <li><a id="p1-4a"></a>PRINT, is a <b>command</b>. It makes what follows it print
        on the display screen. All commands are followed by
        a space.</li>
  <li><a id="p1-4b"></a>"TODAY IS" is the text to be printed. A piece of text in
        quotes like this is called a <b>string</b>.</li>
  <li><a id="p1-4c"></a>A <b>comma</b> makes the next thing to be printed follow on the
        same line after a space.</li>
  <li><a id="p1-4d"></a>DAY is a <b>function</b>. It finds out the date. Here it returns it
        to the print command, which displays it.</li>
  <li><a id="p1-4e"></a>A <b>semi-colon</b> makes the next thing to be printed follow on
        the same line without a space.</li>
  <li>"/" is another string of just one character and MONTH is
        another function.</li>
  <li type="square"><a id="p1-4g"></a>Now press <b>EXE</b> to start a new line, and type:<br>
          <span class="code">GET</span></li>
</ul>

<p>The GET function, waits for a keypress before running the rest
of the program. So when you run DATE:, the date will remain
on the screen until you press a key.


<a id="p1-5a"></a></p><h3>Editing what you've typed</h3>

<p>You can correct what you've typed at any time:
</p><ul>
    <li>Use <b>LEFT</b> , <b>RIGHT</b>, <b>UP</b> and <b>DOWN</b> to move around.</li>
    <li>Use <b>DEL</b> to delete the character to the left of the character and
      hold down <b>SHIFT</b> and press <b>DEL</b> to delete the character under
      the cursor.</li>
    <li>To insert a new line between two existing ones, press <b>EXE</b> on
      the first character of the second one.</li>
    <li>To join two lines, press <b>DEL</b> on the first character of the
      second one.</li>
    <li>To delete a line, press <b>ON/CLEAR</b>.</li></ul>

<a id="p1-5b"></a><p>You can also press <b>MODE</b> and use four of the options on the editor menu
to help you:

</p><table summary="Editor Menu Options">
<tbody><tr><td><b>Find</b></td><td>Takes you to a search-clue you specify (you have to press <b>ON/CLEAR</b> to remove the find prompt).</td></tr>
<tr><td><b>Home</b></td><td> Takes you to the top of the procedure file.</td></tr>
<tr><td><b>End</b></td><td> Takes you to the bottom of the procedure file.</td></tr>
<tr><td><b>Zap</b></td><td>Clears all the lines deleting the whole procedure text so that you can start again.</td></tr>
</tbody></table>

<a id="p1-6a"></a><h3>2 Saving and translating procedures</h3>

<p>When you have finished typing the procedure, you can:
</p><ul>
    <li>Translate it into a form which OPL can run.</li>
    <li>Save it as it is - so you can edit it but not run it.</li>
    <li>Quit and abandon it.</li>
    <li type="square"> Press <b>MODE</b> to get the editor menu. The first three options are:
          <span class="code">Tran Save Quit</span></li></ul>

<p>This diagram illustrates the differences between them.
The bold path shows the normal process of translating a new procedure:

</p><div align="center">
<img src="./LZ_LZ64 Programming Manual - Jaap&#39;s Psion Organiser II Page_files/tranmenu.gif" width="466" height="233" alt="">
</div>

<p>You would normally select Tran, so that you can run the procedure, but
to see what the other two do:

<a id="p1-6b"></a></p><h3>Quit</h3>
<ul><li type="square">Select Quit and you are prompted with the message: <span class="code">Quit? Y/N</span></li>
    <li type="square">Press <b>N</b>, and you return to the procedure editor. (If you
      pressed <b>Y</b>, everything you typed during the editing session would
      be discarded.)</li></ul>


<a id="p1-7a"></a><h3>Tran</h3>
<ul><li type="square"> Select Tran.</li></ul>

<p>The procedure is translated into a form that OPL can run. When
the procedure has been translated, the screen displays this
prompt: <span class="code">Save A:DATE</span>

</p><p>You can now save the translated procedure.
</p><ul><li type="square"> Press <b>MODE</b> to change device if you want to save on a pack, then
      <b>EXE</b> to save.</li></ul>

<p>You return to the Prog menu. When you save the translated version, the
original text version is saved with it. So you can run it and re-edit
it later.


</p><p><b>Syntax errors</b>

</p><p>If you make a typing error, OPL spots it during translation. For
example, if you typed PRONT instead of PRINT or omitted one of
the pair of quotation round a string, this message is displayed:

</p><p><span class="screen">       ERROR       &nbsp;
     SYNTAX ERR    &nbsp;
....................
  press SPACE key  &nbsp;</span>

</p><ul><li type="square"> Press <b>SPACE</b> and you return to the procedure editor, with the
      cursor near the syntax error.</li>
    <li type="square"> Correct it, press <b>MODE</b>, and select Tran again.</li></ul>


<a id="p1-7b"></a><h3>Save</h3>

<p>When you just save a procedure rather than translating it, no error
checking is done. The text is simply saved exactly as you typed it.

</p><p>If you type in part of a procedure and intend to return to it later to
complete it you can select Save instead of Tran so as not to waste
memory by producing an unnecessary translated version.


</p><p><b>Where you should save programs</b>

</p><p>The best place to save programs is on A: or a Rampak. Then, if a
procedure takes a couple of versions before it runs properly, each
version will not use up space:
</p><ul><li>When an edited version is saved on A: or a Rampak, the old
      version is deleted completely each time the new version is saved
      or translated.</li>
    <li>On Datapaks, however, the old versions remain there taking up
      space, you just can't access them.</li></ul>

<p>When a final version of a procedure has been produced on device A: it
is a good idea to copy it to a Datapak.


<a id="p1-8b"></a></p><h3>3 Running a procedure</h3>

<p>When you've successfully translated the procedure, you can run it.
</p><ul><li type="square">From the Prog menu, select Run. The name of the procedure you just
      translated is supplied for you:<br>
      <span class="screen">Run A:Date          </span></li>
    <li type="square">Just press <b>EXE</b> to run the procedure.</li></ul>

<p>When DATE: is run, the screen will first clear and then show something
like this, depending on the date:
<br><span class="screen">TODAY IS 19/8       </span>

</p><p>The last line of the procedure was GET. This instruction simply
waits until you press a key before continuing. So, when you press
a key, the procedure finishes and you return to the Prog menu.


<a id="p1-9a"></a></p><h3>Edit, Print, Dir, Copy, Delete</h3>

<p>Like Run, the remaining Prog options all require you to specify an
existing procedure file.

</p><p>If you haven't left Prog, the name of the procedure you worked on
last is supplied for Edit and Print. You can press <b>EXE</b> to accept it,
or <b>DOWN</b> to get a list of procedures to select from. For detail on selecting
from file lists, see Chapter 12 in the operating manual.


<a id="p1-9b"></a></p><h3>Editing an existing procedure</h3>

<p>The Edit option from the Prog menu allows you to return to an
old procedure to change it or add to it.
</p><ul><li type="square"> Select Edit and press <b>MODE</b> to change device if necessary, then
      select a procedure file.</li></ul>

<p>When you've finished editing the procedure, you can either:
</p><ul><li>Press <b>MODE</b> then <b>EXE</b> to translate and save it.</li></ul>
or, if you make a mess of the editing:
<ul><li>Press <b>MODE</b> then 9 to quit and delete this version of the
      procedure so you can edit the original again.</li></ul>


<a id="p1-9c"></a><h3>Printing a procedure</h3>

<p>The Print option is used to print out a listing of a procedure
on a printer or personal computer.
</p><ul><li type="square"> Select Print then select a procedure file.</li></ul>

<p>If no printer or computer is connected to the Organiser, this
error message is displayed:
<br><span class="screen">   DEVICE MISSING  &nbsp;</span>

</p><p>For more details on printing, see Chapter 17 in the operating
manual.


<a id="p1-10a"></a></p><h3>The procedure directory</h3>

<p>The Dir option on the Prog menu shows you the directory of
procedures stored on the various devices.
</p><ul><li type="square"> Select Dir from the Prog menu. The screen shows:<br>
<span class="screen">Dir A:              </span>
</li></ul>

<p>If necessary, change device with <b>MODE</b>, then list the procedures
with <b>DOWN</b> in the same way as you do in Dir in Utils. See Chapter 15 of
the Operating Manual.


<a id="p1-10b"></a></p><h3>Copying a procedure</h3>

<p>The Copy option in the Prog menu is used to make copies of
procedures from one device to another.
</p><ul><li type="square"> Select Copy from the Prog menu:<br>
<span class="screen">        Copy       &nbsp;
    Select type    &nbsp;
....................
<u>O</u>pl Oplobj Opltxt  &nbsp;</span></li></ul>

<p><b>Opl</b> Copies both the text and translated object code of the procedure.
<br><b>Oplobj</b> Copies only the translated object code part.
<br><b>Opltxt</b> Copies only the editable text part.
</p><ul><li>If you select Opl you will be able to edit and run the copy.</li>
    <li>If you select Oplobj you won't be able to edit it.</li>
    <li>If you select Opltxt, you won't be able to run it until you
      have translated it again.</li></ul>

<p>Copy in Prog works just like Copy in Utils.

</p><p><b>Warning:</b> If you copy a procedure, and one with the same name already
exists on the destination device, the existing one is deleted - even
if the existing one is text only and the one you are copying is
object only.


<a id="p1-11a"></a></p><h3>Deleting a procedure</h3>

<p>The <b>Delete</b> option allows you to delete procedures from any of the devices.
</p><ul><li type="square"> Select Delete to get the prompt: <span class="code">Delete A:_</span></li></ul>

<p>If necessary change device with <b>MODE</b>. Select a file or files to be
deleted in the same way as you do in the Utils Delete option.

<a id="p1-11b"></a></p><h3>Running a procedure from the main menu</h3>

<p>To insert the name of a procedure in the main menu:
</p><ul><li type="square"> On the main menu, press <b>MODE</b> with the cursor where you
      want the name to be.</li>
    <li type="square"> Type in the name of the procedure.</li>
    <li type="square"> Select Opl.</li></ul>

<p>When you select the name, the procedure is run.

</p><p>For example, you could type in, translate and save a procedure like
the one below, then enter its name, ID, in the main menu. When the
item Id is selected, your Organiser will be identified.
</p><p class="program">ID:
CLS
PRINT "IF FOUND PLEASE RING"
PRINT "PAUL SMITH EXT. 998"
GET</p>

<a id="p1-12a"></a><h3>Pausing and quitting procedures when running</h3>

<p>Sometimes you may want to stop a procedure when it's running. To
halt the execution of a procedure:
</p><ul><li type="square"> Press <b>ON/CLEAR</b>.</li></ul>

<p>This will pause it indefinitely. (Unless the procedure was waiting
for a key, with a function such as GET.)
</p><ul><li type="square"> Press <b>Q</b> to quit (or any other key to continue).</li></ul>

<p>If the procedure was run from the main menu, the screen shows:

</p><p><span class="screen">       ERROR       &nbsp;
ESCAPE IN A:procname
....................
  press SPACE key  &nbsp;</span></p>

<ul><li type="square"> Press the <b>SPACE</b> key to return to the main menu.</li></ul>

<p>If the procedure was run from the Prog menu, the screen shows:

</p><p><span class="screen">       ERROR       &nbsp;
       ESCAPE      &nbsp;
....................
Edit A:procname Y/N&nbsp;</span></p>

<p>Press <b>Y</b> if you want to enter the procedure text to edit it, or
press <b>N</b> to return to the Prog menu.


<a id="p1-13a"></a></p><h3>Renaming a procedure</h3>

<p>You can't use Copy to rename a procedure you have to re-save it under
a different name. For example, to rename A:DATE to A:TODAY.
</p><ul><li type="square"> Select Edit to edit A:DATE then select Tran.</li>
    <li type="square"> When you see the Save A:DATE prompt, press <b>ON/CLEAR</b> then enter
      the new name, TODAY and press <b>EXE</b>.</li></ul>

<a id="p1-13b"></a><h3>Translating a procedure for an XP or CM</h3>

<p>If you are creating a procedure to be run on a two-line Organiser
model CM or XP:
</p><ul><li type="square"> Select Xtran instead of Tran when you've finished editing it</li></ul>

<p>When you run a procedure created on an XP or translated with Xtran,
anything printed on the screen has a border like this round it:

</p><p><span class="screen">XXXXXXXXXXXXXXXXXXXX
XX  2-LINE PROC   XX
XX                XX
XXXXXXXXXXXXXXXXXXXX</span>


</p><h3>Summary</h3>

<h3>Entering and running a procedure.</h3>
<ul type="square">
    <li> Select Prog on the main menu.</li>
    <li> Select New.</li>
    <li> Type a name. Press <b>EXE</b>.</li>
    <li> Press <b>EXE</b> again to start a new line. Type in the procedure.</li>
    <li> Press <b>MODE</b> and select Tran (Xtran to run on a two-line Organiser XP or CM).</li>
    <li> Press <b>MODE</b> if you need to change device, then <b>EXE</b> to save.</li>
    <li> Select Run to execute the procedure.</li></ul>


<h3>Inserting a procedure name in the main menu</h3>
<ul type="square">
    <li> On the main menu, press <b>MODE</b> with the cursor where you want the name to be.</li>
    <li> Type in the name of the procedure.</li>
    <li> Select Opl.</li></ul>

<p>When you select the name, the procedure is run.


</p><h3>Escaping from a running procedure</h3>
<ul type="square">
    <li> Press <b>ON/CLEAR</b>.</li>
    <li> Press <b>Q</b> to quit (or any other key to continue).</li></ul>

<hr>

<a id="p2-1a"></a><h2>2 Procedures and variables</h2>

<p>The previous chapter dealt with the mechanics of using the Prog
menu. The next five chapters cover the basic concepts of OPL
programming. If you are familiar with programming languages just
skim through these chapters, or refer instead to the reference sections
which follow.

</p><p>Procedures generally consist of the four steps shown in this simplified
example:

</p><table summary="Steps of a Procedure">
<tbody><tr><td>1 Name</td><td><span class="code">SINE50:</span></td></tr>
<tr><td>2 Declaration of variables</td><td><span class="code">LOCAL x</span></td></tr>
<tr><td>3 Operations upon variables</td><td><span class="code">x=SIN(50)</span></td></tr>
<tr><td>4 Communication of variables</td><td><span class="code">PRINT x</span></td></tr>
</tbody></table>

<p>This chapter deals with these four steps.


<a id="p2-1b"></a></p><h3>1 Procedure names</h3>

<p>e.g. <b>print:</b>, <b>shares89:</b>, <b>TAXCALC:</b>
</p><ul><li>They may be up to 8 characters long and can combine numbers
      and letters. <b>The first character must be a letter.</b></li>
    <li>They end with a colon, but it is only in certain circumstances
      that you have to type this in. For example, you don't have to
      type it in when naming a new procedure but you do when you
      call a procedure from within another one.</li>
    <li>They may be typed in upper or lower case letters.</li></ul>


<a id="p2-2a"></a><h3>2 Declaring variables</h3>

<p>If you were adding together two numbers, in algebra you would
write 'x+y=z'.<br>
In OPL you would write z=x+y but first you would have to <b>declare</b> x,y
and z as variables in order to reserve memory space for them. You would
do this:

</p><p><b>1</b> Declare the variables in order to reserve 3 spaces in memory, called x, y
and z.
<br><span class="code">     LOCAL x,y,z</span>
<br><b>2</b> Assign values to x and y.
<br><span class="code">     x=5
     y=2</span>
<br><b>3</b> Add x and y together and assign the result to z:
<br><span class="code">     z=x+y</span>

</p><p><b>A variable is therefore a named region of memory</b> which at the very
beginning of your procedure you <b>declare</b>. This means that you tell the
Organiser you are going to use the variable so that it will have space
to store the number or text you later assign to it. So in the SINE50
example, the line 'LOCAL x' reserves a memory space named x in which
the value given to x in the next line can be stored.


<a id="p2-2b"></a></p><h3>Variable names</h3>

<p>There are three kinds of variables identified when you declare them by
the format of the variable name. The three kinds are:

</p><p>Floating point variables e.g. x<br>
Integer variables e.g. x%<br>
String variables e.g. x$

</p><p>All variables may be up to 8 characters long. The first character must
be a letter. The other characters may be letters or numbers but not
symbols - except for the identifiers % and $ at the end.


<a id="p2-3a"></a></p><h3>Floating point variables</h3>

<p>A floating point number is one which has a decimal point and then any
number of digits after that point, e.g. 13.567 or 8. or 0.05319 or 6.0

</p><p>You should declare a floating point variable when you know that
the sort of value you are likely assign to it will be a floating point
number.

</p><p><b>A floating point variable name does not have any special symbol at the end.</b>

</p><p>e.g. a, AGE, PROFIT89.

</p><p>Floating point variables are stored to an accuracy of 12 digits and must
be in the range ±9.99999999999E99 to ±1E-99 and 0.


<a id="p2-3b"></a></p><h3>Integer variables</h3>

<p>An integer is a whole number, e.g. 6 or 13 or -3 or 11058

</p><p>You should use integer variables wherever floating point numbers are not
necessary and speed or space are important. Integer arithmetic is faster
than floating point and it occupies two bytes of memory instead of eight.

<a id="p2-3c"></a></p><p><b>An integer variable name ends with a % sign.</b> (The % sign is included in
the 8 characters length.)

</p><p>e.g. a%, AGE%, PROFI89%.

</p><p>Integer variables must be in the range -32768 to +32767.


<a id="p2-3d"></a></p><h3>String variables</h3>

<p>A <b>string</b> is a sequence of characters, alphabetic, numeric or symbolic,
which is treated literally rather than being evaluated. Examples of
strings are: "x + y =" and "01-345-2908" and "profit".

<a id="p2-4a"></a></p><p><b>A string variable name ends with a $ sign.</b> (The sign is included in the 8
characters length.)

</p><p>e.g. a$, NAME$, MAN6$.

</p><p>When declaring a string variable, you must state the maximum
length of the string you expect to assign to it. So if you want to
enter names up to 15 characters long as the value of NAME$, you
have to declare NAME$(15). The number goes in brackets.

</p><p>The maximum length of a string is 255 characters.


<a id="p2-4b"></a></p><h3>The LOCAL and GLOBAL commands</h3>

<p>You must declare your variables immediately after the procedure
name. You may list together all 3 types, in any order; they must be
separated by commas like this:

</p><p><span class="code">LOCAL x,y,a%,NAME$(15),YEAR3%</span>

</p><p>To declare variables you use either the LOCAL or the GLOBAL
command like this:
<br><span class="code">LOCAL x,a%,list$(8)</span>
<br>or
<br><span class="code">GLOBAL x,a%,list$(8)</span>

</p><p>LOCAL and GLOBAL define the <b>range</b> the variables are to be active
in. The basic difference is that:
</p><ul><li>Local variables are limited to the procedure in which they are
      declared.</li>
    <li>Global variables can also be used in any procedures called by the
      procedure in which they are declared.</li></ul>


<h3>Calling procedures</h3>

<p>An OPL program can be made up of more than one procedure. However, you
have to type, translate and save each procedure separately.

</p><p>In the example below, the fourth line of proca: calls another procedure,
procb:. To do this, you just type the procedure name (with the colon).

</p><table summary=""><tbody><tr><td><p class="program">proca:
GLOBAL a%
a%=2
procb:
PRINT a%</p></td><td valign="top"><p class="program">procb:
a%=a%+4</p></td></tr></tbody></table>

<p>You declare a% as a global variable so that it can be used in the
second procedure. In this example the value printed out when
proca: is run is 6.

</p><p>The only danger with global variables is that you may get mistakes
occurring if you accidentally use the same variable name twice. So,
you should use the LOCAL command unless the GLOBAL one is
required.

</p><p>If OPL comes across a variable which isn't declared in that
procedure, it assumes it has been declared in a previous procedure.
OPL will then report a MISSING EXTERNAL error if it can't find
the global variable in a calling procedure.


<a id="p2-5b"></a></p><h3>Other variables</h3>

<p><b>Calculator memories</b>

</p><p>There are ten floating point variables which are always available.
These are the calculator memories m0 to m9. You do not declare
these as variables, as they are always in existence.

</p><p>Values may be assigned to these at any time in any procedure. You
can then access them in the calculator.


<a id="p2-6a"></a></p><p><b>Array variables</b>

</p><p>You may want to declare a large number of similar variables at the
beginning of a program. For this reason. OPL has <b>array variables</b>.

</p><p>The idea is simply that, instead of having to declare variables a, b, c, d
and e, you can declare variables a1 to a5 in one go like this:

</p><table summary="">
<tbody><tr><td width="50%"><span class="code">LOCAL a%(5)</span></td><td>(integer variable array)</td></tr>
<tr><td><span class="code">LOCAL a(5)</span></td><td>(floating point variable array)</td></tr>
<tr><td><span class="code">LOCAL a$(5,8)</span></td><td>(string variable array)</td></tr>
</tbody></table>

<p>Numeric array variables may be thought of as a list of numbers, each with
the same name, but with an index number to differentiate them.

</p><p>When the array is declared, the number in brackets is the number of
elements in it. Here is a simple example assigning values to the elements
of in integer array:

</p><p class="program">procname:
GLOBAL num%(4)
num%(1)=1
num%(2)=3
num%(3)=5
num%(4)=7
PRINT num%(1)+num%(2)+num%(3)+num%(4)</p>

<p>This example just prints the sum of the four elements of the array num%.

</p><p>With strings, you must declare the number of elements in the array
<b>and</b> the maximum length of the strings.

</p><p>For example GLOBAL ARRAY$(5,10) allocates memory space for five strings,
each up to ten characters in length, under the names ARRAY$(1) to ARRAY$(5).
As yet, each of the variables is empty (is a <b>null string</b>), but enough memory
still has to be set aside to contain all of the five strings when full.


<a id="p2-7a"></a></p><h3>3 Operations upon variables</h3>

<p>Once you have declared your variables you can perform any number
of operations on them. This might be a combination of arithmetic
operations, or you might pass the variables to other procedures for
them to operate upon them, or use one of the OPL functions.
Whatever you do, however, you need to understand how your
variables will react according to what type they are and how you
combine them.

</p><p>For example, you cannot divide a string variable by an integer
variable. And if you mix integers and floating point variables in the
same sum one may convert the other into its own type of variable.
The following sections give details of what problems may arise and
how to avoid them.


<a id="p2-7b"></a></p><h3>Mixing integers and floating point variables: automatic type conversion</h3>

<p>In the procedure below there is a potential mistake in the third line
after the name, where the integer variable y% is assigned a floating
point value:

</p><p class="program">procname:
GLOBAL x%,y%
x%=7
y%=3.7+x%
PRINT y%
GET</p>

<p>OPL deals with this in the following way: instead of reporting an
error, OPL carries out an <b>automatic type conversion</b> internally on
the value assigned to the mismatched variable.

</p><p>The right hand side of y%=3.7+x% is evaluated to 10.7. However, the
fractional part of the number is dropped before the result is assigned
to the left hand side, y%. So, the PRINT statement will display the
value 10.

</p><p>Since OPL does not report this as an error, the onus is on you to
ensure that it does not happen - unless you want it to! You must
always take care when mixing variable types that the answer
produced is the one which you expect.

</p><p>In the procedure below where only floating point variables are
used, you can see that another type conversion is made, but does
not cause the value to change:

</p><p class="program">procname:
GLOBAL a,b,c
a=1.2
b=2.7
c=3
PRINT a+b+c</p>

<p>In this procedure, the floating point variable c is given the integer
value 3. An automatic type conversion is carried out in such cases. Here
the result is converted to 3.0, so the real value of the variable remains
the same.

</p><p>If you assign a floating point number to an integer variable, then the
automatic type conversion will generate an integer rounded <b>down</b>.
So if you say a%=2.3 then the value of a% will be 2; but a%=2.9
would also give a% the value 2. And if you assign a negative
floating point number to an integer variable, then the number is still
rounded down - rather than toward zero. So if you say a%=-2.3
then a% will take the value -3. This may not be desirable..

</p><p>If you expect an expression to return a floating point number, you
must ensure that the correct types of number are used within that
expression.

<a id="p2-9a"></a></p><p>It is possible to control how floating point numbers are rounded when
converted. For example, if you wanted to round floating point numbers to
the nearest half (so 2.4 would round to 2.5 and 2.2 to 2) then you might
try the following statement:<br>
<span class="code">r=INT(2*n+0.5)/2</span>
<br>where n is the number to be rounded.

</p><p>This would produce the wrong result, though. To see why substitute a trial
value, say 3.4, instead of n:<br>
<span class="code">INT(2*3.4+0.5)</span> i.e. <span class="code">INT(7.3)</span>
<br>returns the integer 7. But 7/2, <b>when rounded down</b> gives the integer 3,
not 3.5.

</p><p>To obtain 3.5 you must force the division to give a floating point result.
In this case the simplest way to do this is to divide by the floating point
value of 2.0, instead of the integer 2. So the expression:<br>
<span class="code">r=INT(2*n+0.5)/2.0</span>
<br>will give the required result.

</p><p>There is more about integers and floating point variables in the
chapter on Operators.


<a id="p2-9b"></a></p><h3>Mixing strings and numbers</h3>

<p>If you try to allocate a number to a string variable, an error will be
reported. There is no automatic type conversion between string and numeric
variables. However, OPL does have facilities for forcing conversion of
numbers to strings and vice versa. These are the SCI$, FIX$, GEN$, NUM$
and VAL functions.


<a id="p2-10a"></a></p><h3>Concatenating strings</h3>

<p>Adding strings together is as easy as adding numeric variables:
</p><ul><li>If a$ is "DOWN" and b$ is "WIND", then the statement c$=a$+b$
      means c$ is "DOWNWIND".</li></ul>

<p>Alternatively, you could give c$ the same value with the
statement c$="DOWN"+"WIND".

</p><p>When concatenating strings, the result cannot be longer than the maximum
length you declared.


<a id="p2-10b"></a></p><h3>Slicing strings</h3>

<p>You can also split strings up. This process is known as <b>string slicing</b>.

</p><p>There are three functions which allow you to do this. They are LEFT$,
RIGHT$ and MID$. These allow you to access the left, right or middle
portions of a string respectively. For example:
</p><ul><li>If a$="01-234-5782", then b$=LEFT$(a$,2) assigns the variable b$ the
      string 01.</li></ul>

<p>String slicing operations leave the original string unchanged - i.e. a$
would still have the value 01-234-5782 after b$ had gained the value 01.
The exception would be when the left hand side of the expression is the
same string as appears in the right hand side, e.g. a$=LEFT$(a$,4) would
return a string containing the leftmost four characters of a$ and assign
it to a$, thus overwriting the original value.

<a id="p2-10c"></a></p><p><b>Note:</b> If you need to define a string which includes the quotation mark
character (ASCII character 34) then this character must be included twice
in the string. So, if you say a$="x""y""z", then the resulting value of a$
will be x"y"z.


</p><h3>4 Communication of variables</h3>

<p>In the first example procedure at the beginning of this chapter, the
statement PRINT x simply takes the value found in the memory space of
variable x and prints it on the screen.

</p><p>Values can also be passed between procedures. In the example on
page 2-5 [See Calling procedures], the procedure proca: called another
procedure, procb: which returned the adjusted value of a% back to proca:.
The variable a% was declared global to allow this.

</p><p>The rest of this chapter deals with two other ways of communicating values:
entering values from the keyboard using the INPUT command, and passing
values between procedures using parameters.


<a id="p2-11b"></a></p><h3>The INPUT command</h3>

<p>Values can be entered from the keyboard using the INPUT command, as in the
example below.

</p><p>This simple procedure just asks you to enter a number. The number you enter
is assigned to the variable x and is then printed out to the screen with
a message:

</p><p class="program">INPUT:
LOCAL x
CLS
PRINT "ENTER NUMBER"
INPUT x
CLS
PRINT "YOU ENTERED",x
GET</p>

<p>For full details of the INPUT command, see <a href="https://www.jaapsch.net/psion/manlzpg.htm#p9-1a">Chapter 9</a>.


<a id="p2-12a"></a></p><h3>Procedure parameters</h3>

<p>Values can be passed between procedures using parameters. In the VAT
example below, the second procedure VAT1: is followed by a parameter
name (p).

</p><p>The last line of the first procedure PROC1: calls VAT1 with the value of x.
The value of x is copied to the parameter p. VAT1: then prints out this
value plus VAT at 15%.

</p><p class="program">PROC1:
LOCAL x
CLS
PRINT "ENTER PRICE"
INPUT x
VAT1:(x)</p>

<p class="program">VAT1:(p)
CLS
PRINT "PRICE INCLUDING VAT = ",p*1.15
GET</p>

<ul><li>Calling a procedure which has parameters means that your first
      procedure can use local rather than global variables which is
      sometimes neater.</li>
    <li>Parameters differ from variables in that you cannot assign values
      to them. They have an external value passed to them from the calling
      procedure and it is then illegal to assign another value by saying,
      in the above example, p=p+1.</li>
    <li>Parameter names are typed in brackets immediately after the colon of
      the procedure name. Their type is specified as with variables e.g. p
      for a floating point value, p% for an integer and p$ for a string.</li></ul>


<a id="p2-13a"></a><h3>Multiple parameters</h3>

<p>In this similar VAT example the second procedure VAT2: has two parameters.

</p><p>The value of the price variable, x, is passed to the parameter p1 and the
rate of VAT is also a variable, r, which is passed to the parameter p2.
VAT2 then prints out the price plus VAT at the rate specified.

</p><p class="program">PROC2:
LOCAL x, r
CLS
PRINT "ENTER PRICE"
INPUT x
CLS
PRINT "ENTER VAT RATE"
INPUT r
VAT2:(x,r)</p>

<p class="program">VAT2: (p1,p2)
CLS
PRINT p1+p2/100*p1
GET</p>

<ul><li>You can pass variable names, strings in quotes, or actual values to
      parameters.</li>
    <li>When you pass multiple values to multiple parameters you must make
      sure that the order of the values when the procedure is called
      corresponds to the order of parameters after the procedure name. For
      example:
      <br>Procedure call - PROC:("a string",9,3.7)
      <br>Procedure name - PROC:(p$,p%,p)</li></ul>

<a id="p2-14a"></a><h3>The RETURN command</h3>

<p>This VAT example differs from the previous two in that control
does not end with the second procedure but returns instead to the
first.

</p><p>The RETURN command is used to return the value of X plus VAT
at r percent - to be printed out in PROC3:. VAT3: is now just
doing the calculation and not printing. This means it can be called by
other procedures which need this calculation but do not necessarily
need to print it.

</p><p class="program">PROC3:
LOCAL x,r
CLS
PRINT "ENTER PRICE"
INPUT x
CLS
PRINT "ENTER VAT RATE"
INPUT r
CLS
PRINT "PRICE INCLUDING VAT =",VAT3:(x,r)
GET</p>

<p class="program">VAT3:(p1,p2)
RETURN p1+p2/100*p1</p>

<ul><li>Only one value may be returned by the RETURN command.</li>
    <li><a id="p2-14b"></a>The name of a procedure which RETURNs a value must end with the
      correct identifier e.g.. PROC$: for one which returns a string; PROC%
      for one which returns an integer; PROC: for one which returns a
      floating point value (as in this example).</li>
    <li>The RETURN command returns to the point where the procedure was
      called.</li></ul>

<hr>

<a id="p3-1a"></a><h2>3 Loops and branches</h2>

<p>So far we have only considered programs which run in a straight line
from start to finish. They consist of a number of instructions which
are executed in the order they appear in the program; if you want to
carry out an instruction more than once you must repeat it.

</p><p>That is clearly very inefficient. A far more efficient method is for
the program to be able to loop around a particular part as many
times as you require, or until a certain condition is met.

</p><p>There are a number of ways of doing this in OPL.

</p><p>The first two are the <b>DO/UNTIL</b> and the <b>WHILE/ENDWH</b> loops. These
are known as structures. They operate in a similar way to each other, with one
difference.
</p><ul><li>The DO/UNTIL structure tests for a condition being fulfilled at
      the end of the loop.</li>
    <li>The WHILE/ENDWH structure tests the condition at the start of the loop.</li></ul>

<a id="p3-1b"></a><p>You can have up to eight loops nested within each other.


<a id="p3-2a"></a></p><h3>The DO/UNTIL loop</h3>

<p>Here is an example of a DO/UNTIL loop:

</p><p class="program">a%=10
DO
 PRINT "A=";a%
 a%=a%-1
UNTIL a%=0</p>

<p>First 10 is assigned to a%. The loop starts on the next line, with the
instruction DO. This says to OPL:

</p><p>"Execute all the following instructions until an UNTIL is reached. If
the condition following UNTIL is not met, repeat the same set of
instructions until it is."

</p><p>The next line displays "A=", followed by the value of a%. The
first time through the loop, this is 10.

</p><p>Next, the value of a% has 1 subtracted from it so that a% is 9. Now
comes UNTIL, followed by a condition. The condition is that a% is
equal to zero. It isn't yet, so the program returns to DO and the loop
is repeated. Now a% decrements to 8, and again the condition fails.
This process continues until a% does equal zero.

</p><p>When a% equals zero the loop finishes and the program continues with the
instructions after UNTIL.


<a id="p3-2b"></a></p><h3>The WHILE/ENDWH loop</h3>

<p>The WHILE/ENDWH loop is similar, except that the test condition is at
the beginning. For example:

</p><p class="program">a=4.1
b=2.7
WHILE a&gt;b
 PRINT "a is greater than b"
 b=b+1.04
ENDWH</p>

<a id="p3-3a"></a><h3>BREAK</h3>

<p>BREAK can be used in conjunction with an IF statement, see below, to break
out of a DO or WHILE loop. It jumps to the instruction after the end of the
loop.


<a id="p3-3b"></a></p><h3>Labels and jumps</h3>

<p>Another command which can direct the program out of a straight sequence is
<b>GOTO</b>. This jumps to a <b>label</b>.

</p><p>In this example, when the program reaches the GOTO, it jumps to the
line beginning with the label exit::.

</p><p class="program">GOTO exit::
PRINT "MISS THIS LINE"
PRINT "AND THIS ONE"
exit::</p>

<p>Labels end in a double colon.

</p><p>The label must be in the same procedure as the GOTO, and the jump
is not conditional, it always happens.


<a id="p3-3c"></a></p><h3>Branches</h3>

<p>GOTO is a way of <b>branching</b>, but it is a fairly crude tool and can
make procedures difficult to read.

</p><p>Better is the <b>IF/ELSEIF/ELSE/ENDIF</b> structure. This structure is used to
perform one or more instructions IF a condition is met. If the condition
is not met, you can use an ELSEIF instruction, to test for another
condition. You can have any number of ELSEIF instructions within an
IF/ENDIF structure.

</p><p>After all likely things are catered for by the ELSEIF instructions, other
possibilities can be catered for by an ELSE statement, followed at the end
by the ENDIF statement. Here is an example:

</p><p class="program">whatkey:
LOCAL g%
g%=GET
PRINT "THAT KEY IS"
IF g%&gt;64 AND g%&lt;91
 PRINT "UPPER CASE"
ELSEIF g%&gt;96 AND g%&lt;123
 PRINT "lower case"
ELSE
 PRINT "NOT A LETTER."
ENDIF
GET</p>

<p>This just waits for a key to be pressed, and then prints that it is either
a lower or upper case letter. (If you don't realise the significance of the
numbers 64 and 91, see <a href="https://www.jaapsch.net/psion/manlzpg.htm#A-1a">Appendix A</a>.) If it is not a letter at all, then that
is printed, as allowed for by the ELSE statement.

</p><p>ELSEIF and ELSE statements are optional, but for every IF there must be a
corresponding ENDIF.


<a id="p3-4b"></a></p><h3>Endless Loops</h3>

<p><b>ESCAPE OFF, GET, KEY and INPUT must be used with caution in loops</b>
for the following reasons:

</p><p>To halt the execution of a procedure, you normally press <b>ON/CLEAR</b>
then <b>Q</b>:
</p><ul>
    <li>If you've used an ESCAPE OFF command, you can't do this, as this
      disables <b>ON/CLEAR</b>. So you can only escape by removing the battery and
      thus losing data.</li>
    <li>If you've used a function such as GET or KEY to read a keypress, you
      have to press <b>ON/CLEAR</b> quickly followed by <b>Q</b> and repeat this very
      quickly a few times. This may be very difficult to do.</li></ul>


<hr>

<a id="p4-1a"></a><h2>4 Operators</h2>

<p><b>Arithmetic operators</b>
</p><table summary="Arithmetic Operators">
<tbody><tr><td><span class="code"><b>+</b></span></td><td>add</td></tr>
<tr><td><span class="code"><b>-</b></span></td><td>subtract</td></tr>
<tr><td><span class="code"><b>*</b></span></td><td>multiply</td></tr>
<tr><td><span class="code"><b>/</b></span></td><td>divide</td></tr>
<tr><td><span class="code"><b>**</b></span></td><td>raise to a power</td></tr>
<tr><td><span class="code"><b>-</b></span></td><td>unary minus (make negative)</td></tr>
<tr><td><span class="code"><b>%</b></span></td><td>percent</td></tr>
</tbody></table>


<p><b>Comparison operators</b>
</p><table summary="Comparison Operators">
<tbody><tr><td><span class="code"><b>&gt;</b></span></td><td>greater than</td></tr>
<tr><td><span class="code"><b>&gt;=</b></span></td><td>greater than or equal to</td></tr>
<tr><td><span class="code"><b>&lt;</b></span></td><td>less than</td></tr>
<tr><td><span class="code"><b>&lt;=</b></span></td><td>less than or equal to</td></tr>
<tr><td><span class="code"><b>=</b></span></td><td>equal to</td></tr>
<tr><td><span class="code"><b>&lt;&gt;</b></span></td><td>not equal to</td></tr>
</tbody></table>

<p><b>Logical operators</b>
</p><p class="code">AND
OR
NOT</p>


<a id="p4-1b"></a><h3>Operator precedence</h3>
<table summary="Operator precedence">
<tbody><tr><td>Highest:</td>
    <td><span class="code">**</span></td></tr>
<tr><td></td>
    <td><span class="code">-</span> (Unary minus)<span class="code"> NOT</span></td></tr>
<tr><td></td>
    <td><span class="code">* /</span></td></tr>
<tr><td></td>
    <td><span class="code">+ -</span></td></tr>
<tr><td></td>
    <td><span class="code">= &gt; &lt; &lt;&gt; &gt;= &lt;=</span></td></tr>
<tr><td>Lowest:</td>
    <td><span class="code">AND OR</span></td></tr>
</tbody></table>

<p>The percent operator % is rather different as its effect depends
on the operator it is combined with. The way % works is described
in the calculator chapter of the operating manual.


</p><h3>Using Brackets</h3>

<p>An expression such as a+b+c presents no problems, as the result is
the same whichever addition is done first. However, you may want
to enforce precedence with brackets. For example:
</p><p class="program">a+b*c/d
</p><p>is evaluated in the order: b multiplied by c, then divided by d, then
added to a. To perform the addition and the division before the
multiplication, use brackets:
</p><p class="program">(a+b)*(c/d)

</p><ul>
  <li>In an expression where all operators have equal precedence, they are
      evaluated from left to right</li>
  <li>Powers, however, are evaluated right to left. So for example, in the
      expression:
      <p class="program">a%**b%**c%</p>
      <p>b% will first be raised to the power of c% and the resulting value will
      be used as the power of a%.</p></li>
</ul>

<p>When in doubt, simply use brackets.


<a id="p4-2b"></a></p><h3>Precedence of integer and floating point values</h3>

<p>You are free to mix floating point and integer values, in expressions, but
be aware how OPL handles the mix:
</p><ul>
   <li>Floating point variables take priority over integers. So, in an
      expression linked by an operator to a floating point number, integers
      will be converted to floating point.
  <p><b>but then</b>
      </p></li>
    <li>The result of the right hand side of an expression is converted to
      whatever type the left hand side is.</li></ul>

<p>For example, your procedure might include the expression:
</p><p class="program">a%=b%+c</p>

<p>This is handled like this: b% is converted to floating point and added to c.
The resulting floating point value is then automatically converted to an
integer in order to be assigned to the integer variable a%.

</p><p>These conversions may produce odd results, so be careful. For
example, a%=3.0*(7/2) assigns 9 to a%, but a%=(3.0*7)/2 assigns 10 to a%.


<a id="p4-3b"></a></p><h3>Logical expressions</h3>

<p>The comparison operators and logical operators are based on the idea that
a certain situation can be evaluated as either true or false. For example,
if a%=6 and b%=8, a%&gt;b% would be false. They are useful for setting up
alternative paths in your procedures. For example you could say:

</p><p class="program">IF salary&lt;expenses
 PRINT "bad"
ELSEIF salary&gt;expenses
 PRINT "good"
ENDIF</p>

<p>You can also make use of the fact that the result of these logical
expressions is represented by an integer:
</p><ul><li>True is represented by the integer -1</li>
    <li>False is represented by the integer 0 (zero)</li></ul>

<p>These integers can be returned to a variable or printed out to the
screen to tell you whether a particular condition is true or false, or
used in an IF statement.

</p><p>For example, in a procedure you might arrive at two sub-totals, a and
b. You want to find out which is the greater. So include the
statement, PRINT a&gt;b. If zero is displayed, a and b are equal or b is
the larger number but if - 1 is displayed, 'a&gt;b' is true - a is the larger.

</p><table summary="Comparison Operator Examples">
<tbody><tr><td width="40"></td><td width="100">Example</td><td width="300">Result</td><td>Integer Returned</td></tr>
<tr><td colspan="4">&nbsp;</td></tr>
<tr><td rowspan="2">&lt;</td>
    <td rowspan="2">a&lt;b</td>
    <td>True if a less than b</td>
    <td>-1</td></tr>
<tr><td>False if a greater than or equal to b</td>
    <td>0</td></tr>
<tr><td colspan="4">&nbsp;</td></tr>
<tr><td rowspan="2">&gt;</td>
    <td rowspan="2">a&gt;b</td>
    <td>True if a greater than b</td>
    <td>-1</td></tr>
<tr><td>False if a less than or equal to b</td>
    <td>0</td></tr>
<tr><td colspan="4">&nbsp;</td></tr>
<tr><td rowspan="2">&lt;=</td>
    <td rowspan="2">a&lt;=b</td>
    <td>True if a less than or equal b</td>
    <td>-1</td></tr>
<tr><td>False if a greater than b</td>
    <td>0</td></tr>
<tr><td colspan="4">&nbsp;</td></tr>
<tr><td rowspan="2">&gt;=</td>
    <td rowspan="2">a&gt;=b</td>
    <td>True if a greater than or equal to b</td>
    <td>-1</td></tr>
<tr><td>False if a less than b</td>
    <td>0</td></tr>
<tr><td colspan="4">&nbsp;</td></tr>
<tr><td rowspan="2">&lt;&gt;</td>
    <td rowspan="2">a&lt;&gt;b</td>
    <td>True if a not equal to b</td>
    <td>-1</td></tr>
<tr><td>False if a equal to b</td>
    <td>0</td></tr>
<tr><td colspan="4">&nbsp;</td></tr>
<tr><td rowspan="2">=</td>
    <td rowspan="2">a=b</td>
    <td>True if a equal to b</td>
    <td>-1</td></tr>
<tr><td>False if a not equal to b</td>
    <td>0</td></tr>
</tbody></table>

<p>You can use these-operators with a mixture of floating point or integer
values. However, if one side of the comparison is floating point, and the
other is an integer, the integer is converted to a floating point. So
if a%=1 and b=1.2, b&gt;a% is true. You can't use a mix of string and numeric
values, so a$&lt;b is invalid.

</p><p>Few programmers need the following information, so skip the rest
of the chapter if it seems daunting.

<a id="p4-5a"></a></p><p>The <b>logical operators</b> AND, OR and NOT have different effects depending on
whether they are used with floating point numbers or integers:

<a id="p4-5b"></a></p><p><b>1 When used with floating point numbers only,</b> the logical operators
have the following effects:

</p><table summary="Comparison Operator Examples">
<tbody><tr><td>Example</td><td>Result</td><td>Integer Returned</td></tr>
<tr><td rowspan="2">a AND b</td>
    <td>True if both a and b are non-zero</td>
    <td>-1</td></tr>
<tr><td>False if either a or b are zero</td>
    <td>0</td></tr>
<tr><td rowspan="2">a OR b</td>
    <td>True if either a or b are non-zero</td>
    <td>-1</td></tr>
<tr><td>False if both a and b are zero</td>
    <td>0</td></tr>
<tr><td rowspan="2">NOT a</td>
    <td>True if a is zero</td>
    <td>-1</td></tr>
<tr><td>False if a is non-zero</td>
    <td>0</td></tr>
</tbody></table>

<a id="p4-5c"></a><p><b>2 When used with integer values only</b>, AND, OR and NOT are bitwise
logical operators.

</p><p>The way the Organiser holds integer numbers internally is as a 16-bit
binary code. So, 7 looks like this: 0000000000000111
The Organiser's numerical range is +32767 to -32768. 32767 is the largest
number that can be represented with 15 binary bits. The 16th bit is used
for the + or -.

</p><p>As the operators are bitwise they perform the operation  on first the 1st
bit, then the 2nd, up to the 16th bit.

</p><p><b>AND</b> The statement PRINT 12 AND 10 prints 8. To understand this, write 12
and 10 in binary:<br>
<span class="code">  12    0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0
  10    0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0</span>

</p><p>AND acts on each pair of bits. Thus, working from left to right -
discounting the first 12 bits:

<br>1 AND 1 →  1
<br>1 AND 0 →  0
<br>0 AND 1 →  0
<br>0 AND 0 →  0

</p><p>The result is therefore the binary number 1000, or 8.

</p><p><b>OR</b> What result would the statement PRINT 12 OR 10 give? Again, write
down the numbers in binary and apply the operator to each pair of digits:

<br>1 OR 1 →  1
<br>1 OR 0 →  1
<br>0 OR 1 →  1
<br>0 OR 0 →  0

</p><p>The result is the binary number 1110, or 14 in decimal.

</p><p><b>NOT</b> NOT works on only one number. It returns the one's complement,
i.e. it replaces 0s with 1s and 1s with 0s.

</p><p>So if 7 looks like this: 0000000000000111
<br>NOT 7 will look like this: 1111111111111000

</p><p>This is the binary representation of -8.

</p><p><b>Hint.</b> A quick way of calculating NOT for integers is to add 1 to the
original number and reverse its sign. Thus, NOT 23 is -24, NOT 0 is -1
and NOT -1 is 0. The last two results are the same for floating points.

</p><hr>

<a id="p5-1a"></a><h2>5 Handling data files</h2>

<p>When you use the SAVE option from the main menu your records are saved in a
file called MAIN. You can also create extra data files in the Xfiles option.
You can access these files and the records in them from OPL. You can also
create new files and then manipulate them. This chapter explains how to
do this.

</p><div align="center">
<img src="./LZ_LZ64 Programming Manual - Jaap&#39;s Psion Organiser II Page_files/manlzpg51.gif" width="440" height="190" alt="">
</div>

<p><b>There are also three examples of data file handling programs at the end of
the example procedures chapter.</b> It may be a good idea to refer to those
programs while you read this chapter.


<a id="p5-2a"></a></p><h3>Files, records and fields</h3>

<p>The data file MAIN and any extra ones you create contain <b>records</b>
which are divided into <b>fields</b>. When you save a record from the main
menu with the SAVE option, you start a new field every time you start a new
line by pressing <b>DOWN</b>.

</p><p>In a name and address file, in each record, there might be a name field,
a telephone number field, and separate fields for each line of the address.

</p><div align="center">
<img src="./LZ_LZ64 Programming Manual - Jaap&#39;s Psion Organiser II Page_files/manlzpg52.gif" width="479" height="324" alt="">
</div>

<a id="p5-3a"></a><h3>Creating a data file</h3>

<p>Before you can start to enter data into a new data file, you must create
the file on one of the devices using New in Xfiles or the CREATE command
in OPL.

</p><p>With CREATE in OPL you have more control, as you specify how many fields
there can be in each record, and what type of data can go in each field.
The CREATE command has this syntax:
<br><span class="code">CREATE "&lt;dev&gt;fname",logname,fldnm1,fldnm2</span>

</p><p><b>"&lt;dev&gt;fname"</b>, is the device (A:, B: or C:) which the
file is to be on, and then the file name. This all goes in quotes as a string, e.g.
"a:clients". You can also assign this device and file name string to a
string variable (e.g. cl$="a:clients") and then use the variable name
(cl$) as the parameter. The file name may be up to 8 characters long.

<a id="p5-3c"></a></p><p><b>logname</b> is the <b>logical file name</b>. This may be A, B, C or D.
You use this logical file name to refer to the file from within the program.

<a id="p5-3d"></a></p><p><b>fldnm1, fldnm2</b> are the field names. There may be up to 16 fields in
any record, and these may be given a qualifier, either % or $, to signify
integer data or string data respectively. Fields containing floating point
data need no qualifier. Field names may be up to 8 characters long
including any qualifier used.

</p><p>An example of a CREATE command might be:

</p><p>CREATE "a:clients",B,nm$,tel$,ad1$,ad2$,ad3$

</p><p>When a file has been created, it is automatically open. This means records
can be saved to it immediately. It also becomes the current file which means
that when you use one of the commands for manipulating records, they operate
on this file.


<a id="p5-4a"></a></p><h3>Adding records to a file</h3>

<p>You add records to a data file field by field. First you assign some values
to the current field names, then you use the APPEND command to add them to
the file.


<a id="p5-4b"></a></p><h3>Assigning values to field names</h3>

<p>The field names act in a similar way to variables, and can be assigned values
and used in INPUT statements. The field name must be used with the logical
file name like this:
<br><span class="code">INPUT B.name$</span>
<br>or this
<br><span class="code">B.name$="MR Bruno"</span>

</p><p>where B is the logical file name and name$ is the name of the field. These
are separated by a full stop.


<a id="p5-4c"></a></p><h3>Appending the fields</h3>

<p>When you have assigned values to the fields, you add them to the open file
with the <b>APPEND</b> command. They are always added as the last record in the
data file. If the file is a new one, this will be the first record.

</p><p>The APPEND command has no parameters - the field values are automatically
added to the file in the correct order and format.

</p><p>If you try to assign a text string to a numeric field name, an error will
be reported.

</p><p><b>See the second procedure (insert:) in program no. 6 of <a href="https://www.jaapsch.net/psion/manlzpg.htm#p8-11a">Chapter 8</a> for an
example of adding records to a data file.</b>

</p><p>At any time while a data file is open, the field names currently in use
can be used like any other variable - for example, in a PRINT statement,
or a string or numeric expression. However, in order to operate on a
particular field, you must make the record containing it the current one.


<a id="p5-5a"></a></p><h3>Changing the current record</h3>

<p>Before you can erase a record or operate on the fields in it you must make
it current. You can change the current record by using any of the six
commands and functions below.

</p><p><b>FIRST</b> moves to the first record in a file.

</p><p><b>NEXT</b> moves to the following record in a file. If the end of the file is
passed, <b>NEXT</b> does not report an error. The current record will then be
null. This condition can be tested for with the EOF function.

</p><p><b>BACK</b> moves to the previous record in the file. If the current record is
the first record in the file then the current record does not change.

</p><p><b>LAST</b> moves to the last record in the file.

</p><p><b>POSITION</b> moves to a particular record. For example, the
instruction POSITION 3 makes record 3 (the first record is record 1)
the current record. You can find the current record number by using
the POS function which returns the number of the current record.

</p><p><b>FIND</b> moves to the record which contains a search string you specify.


<a id="p5-6a"></a></p><h3>Finding a record</h3>

<p>The FIND function acts like the main menu Find, but without wild cards.
The difference is that whereas the main menu Find prints the record on the
screen, this function makes it the current record so that you can operate
on it: editing it, erasing it, or just displaying it.

</p><p>For example, the line
<br><span class="code">r%=FIND("HOLMES")</span>
<br>would make the first record containing the string "HOLMES" the current
record and return the number of that record to the variable r%. If the
number returned is zero, the string was not found.

</p><p>There is another function, FINDW, which is the same as FIND but does allow
wild cards. So, to find the first record containing ORDER and 89 use this
instruction:
</p><p class="program">r%=FINDW("*ORDER*89*")</p>

<p>+ Matches any character.
<br>* Matches any group of characters.</p>

<p>The procedure called search: in program no. 6 in <a href="https://www.jaapsch.net/psion/manlzpg.htm#p8-11a">Chapter 8</a> is an example
of how to find and edit records.


<a id="p5-6b"></a></p><h3>Erasing a record</h3>

<p>To erase a record, make that record current by use of one of the commands
FIRST, NEXT, BACK, LAST, POSITION or FIND and then use the ERASE command.
This removes the current record from the file and renumbers the ones that
follow.

</p><p>The final procedure (erase:) in program no. 6 in <a href="https://www.jaapsch.net/psion/manlzpg.htm#p8-11a">Chapter 8</a> is an example of
how to find and erase records.


<a id="p5-7a"></a></p><h3>Opening a file</h3>

<p>When you first CREATE a data file it is automatically open but it closes
again when the program ends. To open the file again in another program, you
use the OPEN command.

</p><p>The syntax of the OPEN command is the same as for the CREATE command. You
must use the same device and file name as when you first created it, but
when opening it in a different program, you can give it a different logical
file name and give the fields different names. For example, a file which was
created in one program with the command:
<br><span class="code">CREATE "c:address",D,name$,num$,add$,add2$</span>
<br>can be opened in another program by the command:
<br><span class="code">OPEN "c:address",A,a$,b$,c$,d$</span>

</p><p>Up to four files may be open at any one time, and these may be spread over
any of the three devices. Each must be referred to in the program by a
different logical name. So, if you have 4 files open, one is A one is B one
is C and the other is D.

</p><p>If you are going to edit or erase records in the file, you need to include
all the fields you are going to operate on in the OPEN command. However, if
you are just going to search for strings and display records, you only need
to include the first field in the OPEN command, like this:
<br><span class="code">OPEN "c:address",A,a$</span>

<a id="p5-8a"></a></p><h3>Changing the current file</h3>

<p>When a file is created or opened, that file is then automatically the
current file and all access is to that file until you say you want to USE a
different one. The <b>USE</b> command makes a file current. You refer to the
file by its logical file name. For example:
<br><span class="code">USE B</span>

</p><p>In this example the file with the logical file name B (as specified in the
OPEN or CREATE command which opened it) becomes the current file. All access
is now to this file until you change the current file with another USE
command or OPEN or CREATE another file. If you attempt to use a file which
has not previously been opened, an error is reported.


<a id="p5-8b"></a></p><h3>Closing and deleting a file</h3>

<p>Data files close automatically when programs end. However, when you have
finished accessing a particular file, you can close it with the CLOSE
command which closes the current file.

</p><p>You might want to close a file if you already have 4 files open in a
program, and you want to open another, or if you want to delete the file.
There is a command <b>DELETE</b> for deleting data files, but the file to be
deleted must be closed first.


</p><h3>More information on data file handling</h3>

<p>See the beginning of <a href="https://www.jaapsch.net/psion/manlzpg.htm#p9-1a">Chapter 9</a> for a summary of all the data file handling
commands and functions. Then look up each one for more detail.

</p><p>Look at programs 6, 7 and 8 in <a href="https://www.jaapsch.net/psion/manlzpg.htm#p8-11a">Chapter 8</a> for examples of data file handling
programs.

</p><hr>

<a id="p6-1a"></a><h2>6 Handling any type of file</h2>

<p>Most of the file handling commands and functions are only for data files.

</p><p>However there are three, COPYW, DELETEW and DIRW$, which operate on any
type of file. You indicate the type of file with these extensions:

</p><table summary="File Extensions">
<tbody><tr><td>Data file and diary file<br>
(ODB stands for Organiser Data Base.)</td><td><b>.ODB</b></td></tr>
<tr><td>OPL procedure</td><td><b>.OPL</b></td></tr>
<tr><td>Notepad file</td><td><b>.NTS</b></td></tr>
<tr><td>Comms Link setup file</td><td><b>.COM</b></td></tr>
<tr><td>Spreadsheet file</td><td><b>.PLN</b></td></tr>
<tr><td>Pager setup file</td><td><b>.PAG</b></td></tr>
<tr><td>Diary file from XP or CM</td><td><b>.DIA</b></td></tr>
</tbody></table>

<p>There are also two extra extensions for COPYW only. Use these to copy only
one part of an OPL procedure.

</p><table summary="">
<tbody><tr><td>OPL procedure (text only)</td><td><b>.OPT</b></td></tr>
<tr><td>OPL procedure (object only)</td><td><b>.OPO</b></td></tr>
</tbody></table>

<p>You can also use wild cards with COPYW, DELETEW and DIRW$. The wild cards
are the normal ones: + is any character, * is any group of characters.


</p><h3>Examples</h3>

<p><span class="code">COPYW "A:*88.OPL","B:"</span><br>
Copies all the OPL procedures whose names end in 88 from A: to B:

</p><p><span class="code">DELETEW "C:*.NTS"</span><br>
Deletes an the notepad files on C:

</p><p><span class="code">DIRW$ ("A: R*")</span><br>
Returns the name of the first file of any type on A: which starts with
the letter R.


<a id="p6-2a"></a></p><h3>Diary files</h3>

<p>Diary files are saved as data files. Each entry is a record
with this two field format:
</p><p><span class="screen">1989042712000100   &nbsp;
JAMES BIRTHDAY      </span>

</p><p>in this example, the first field carries this information:

</p><table summary="Diary Record Example">
<tbody><tr><td><b>1989</b></td><td>The year</td></tr>
<tr><td><b>04</b></td><td>The month</td></tr>
<tr><td><b>27</b></td><td>The date</td></tr>
<tr><td><b>1200</b></td><td>The start time</td></tr>
<tr><td><b>01</b></td><td>The duration - one 15 minute interval</td></tr>
<tr><td><b>00</b></td><td>The alarm pre-warning time. In this case there is no alarm so it's zero.</td></tr>
</tbody></table>


<p>You can open a saved diary file in Xfiles, and then find and update records
in it. For example, you could find all your annual entries such as
birthdays and change 1989 to 1990. If you then restored the diary and
merged it with the current one you wouldn't need to put in all the birthday
entries again at the end of the year. However, be careful to use the right
format, or you won't be able to restore the diary.

</p><p>You could also do this in OPL using the data file handling and string
handling commands. There is a program in <a href="https://www.jaapsch.net/psion/manlzpg.htm#p8-1a">Chapter 8</a> which does this.

</p><hr>

<a id="p7-1a"></a><h2>7 Error handling</h2>

<p>This chapter covers commonly made errors, then error trapping. There is a
list of the OPL error messages in <a href="https://www.jaapsch.net/psion/manlzpg.htm#D-1">Appendix D</a>.


</p><h3>Common errors</h3>

<p>All programming languages are very particular about the way commands and
functions are used, especially in the way program statements are laid out.

</p><p>Below are a number of errors which are easy to make in OPL. The incorrect
statements are in bold and the correct versions are on the right.

</p><p><b>Punctuation errors</b>

</p><p>Omitting the colon between statements on a multi-statement line:

</p><table summary="Example error">
<tbody><tr><td>Incorrect</td><td>Correct</td></tr>
<tr><td><span class="code"><b>a$="text" PRINT a$</b></span></td>
    <td><span class="code">a$="text" :PRINT a$</span></td></tr></tbody></table>

<p>Omitting the colon after a called procedure name:
</p><table summary="Example error">
<tbody><tr><td>Incorrect</td><td>Correct</td></tr>
<tr><td><span class="code">proc1:<br>GLOBAL a,b,c<br>.<br>.<br><b>proc2</b></span></td>
    <td><span class="code">proc1:<br>GLOBAL a,b,c<br>.<br>.<br>proc2:</span></td></tr></tbody></table>


<p>Omitting one or more of the colons after a label:
</p><table summary="Example error">
<tbody><tr><td>Incorrect</td><td>Correct</td></tr>
<tr><td><span class="code">proc1:<br><b>GOTO below:</b><br>.<br>.<br>below::</span></td>
    <td><span class="code">proc1:<br>GOTO below::<br>.<br>.<br>below::</span></td></tr></tbody></table>

<p>Omitting the space before the colon between statements on a multi-statement line:

</p><table summary="Example error">
<tbody><tr><td>Incorrect</td><td>Correct</td></tr>
<tr><td><span class="code">proc1:<br><b>a$=b$:PRINT a$</b></span></td>
    <td><span class="code">proc1:<br>a$=b$: PRINT a$</span></td></tr></tbody></table>

<p><b>Parameter errors</b>

</p><p>Passing a floating point value to a procedure which requires an integer -
here the procedure proc2:(x%).

</p><table summary="Example error">
<tbody><tr><td>Incorrect</td><td>Correct</td></tr>
<tr><td><span class="code"><b>2*6+proc2:(PI)</b></span></td>
    <td><span class="code">2*6+proc2:(INT(PI))</span></td></tr></tbody></table>

<p>This may also happen when a procedure is called from the calculator. The
calculator converts all numbers to floating point, so:
</p><table summary="Example error">
<tbody><tr><td>Incorrect</td><td>Correct</td></tr>
<tr><td><span class="code">Calc:<b>proc2:(3)</b></span></td>
    <td><span class="code">Calc:proc2:(INT(3))</span></td></tr></tbody></table>

<p>Passing an integer to a procedure which requires a floating point value -
here the procedure proc3:(x)

</p><table summary="Example error">
<tbody><tr><td>Incorrect</td><td>Correct</td></tr>
<tr><td><span class="code">proc1:<br>.<br>.<br><b>proc3:(2/3)</b></span></td>
    <td><span class="code">proc1:<br>.<br>.<br>proc3:(2.0/3)</span></td></tr></tbody></table>

<p>Passing the wrong number of parameters to a procedure - here, the
procedure proc4:(x,y)
</p><table summary="Example error">
<tbody><tr><td>Incorrect</td><td>Correct</td></tr>
<tr><td><span class="code">proc1:<br>.<br>.<br><b>proc4:(3.7)</b></span></td>
    <td><span class="code">proc1:<br>.<br>.<br>proc4:(3.7,2.5)</span></td></tr></tbody></table>

<p><b>Integer size error</b>

</p><p>OPL only allows numbers between minus 32768 and plus 32767 to
be assigned to integer variables, so any expression which exceeds
these limits will cause an error:

</p><table summary="Example error">
<tbody><tr><td>Incorrect</td><td>Correct</td></tr>
<tr><td><span class="code">proc1:<br>LOCAL <b>a%<br>a%=100*2468</b></span></td>
    <td><span class="code">proc1:<br>LOCAL a<br>a=100.0*2468</span></td></tr></tbody></table>

<p><b>Structure errors</b>

</p><p>The structures allowed within OPL are DO/UNTIL, WHILE/ENDWH and
IF/ELSEIF/ELSE/ENDIF. These may all be nested within one another to up
to eight structures deep. Attempting to nest to a greater depth than this
will cause an error. Mixing up the three structures e.g. by matching up DO
with WHILE, will also cause an error:

</p><table summary="Example error">
<tbody><tr><td>Incorrect</td><td>Correct</td></tr>
<tr><td><span class="code">proc1:<br>.<br>DO<br>.<br><b>WHILE</b> a&lt;2</span></td>
    <td><span class="code">proc1:<br>.<br>DO<br>.<br>UNTIL a&gt;=2</span></td></tr></tbody></table>

<a id="p7-4a"></a><h3>Run-time errors</h3>

<p>If an error occurs when you run a program, the program stops
and an error message is displayed.

</p><p>If you are running the procedure from the main menu, just press
<b>SPACE</b> to return to the menu.

</p><p>However if you are running it from the Prog menu, you get a chance
to edit it. Here a call has been made to a procedure called subproc:
which does not exist:

<br><span class="screen">
    MISSING PROC   &nbsp;
      SUBPROC      &nbsp;
....................
Edit A:MAINPROC Y/N&nbsp;</span>

</p><p>Press <b>Y</b> if you want to edit the procedure. If the source
code is available, you are returned to the OPL editor to
correct the offending line. Press <b>N</b> or <b>ON/CLEAR</b> if you
don't want to edit it.

</p><p>When you have done this, press MODE to get the
editor menu, and either translate, save or quit the
procedure. If you quit, the edits you have made this
session are abandoned.


<a id="p7-4b"></a></p><h3>Error trapping</h3>

<p>In the case of the run time errors described above, the program stops
to display the error message. There are ways of avoiding this by
trapping errors and dealing with them yourself within the program -
but they put you in full control and <b>must be used carefully</b>. The
tools used to control errors are <b>ONERR</b>, <b>TRAP</b>, <b>ERR</b>,
<b>ERR$</b> and <b>RAISE</b>:
</p><ul><li>ONERR traps any errors which occur and redirects the program to
      your own error handler.</li>
    <li>TRAP traps only errors on a particular command.</li>
    <li>ERR and ERR$ identify which error has occurred.</li>
    <li>RAISE generates an error. (often used for testing)</li></ul>


<a id="p7-5a"></a><h3>ONERR label:: and ONERR OFF</h3>

<p>ONERR, is used to redirect program control to a label if an error
occurs. This is useful if you want to provide your own error handling
routine, such as printing out a message for an error you anticipate.
ONERR is followed by the label name which ends in two colons. The
label itself can be either in the same procedure or in a procedure before
it in the same program.

</p><p>In the example below, LPRINT is being used to print to an attached
printer. Normally, when no printer is connected, the message
DEVICE MISSING is displayed. Here a more precise message,
CONNECT PRINTER, is supplied by the programmer:

</p><p class="program">ONERR noprint::
LPRINT "Dear Sir"
RETURN
noprint::
ONERR OFF :IF ERR=194 :RAISE ERR :ENDIF
PRINT "CONNECT PRINTER"
GET</p>

<p>The first line causes a jump to the label noprint:: if an error occurs. If
no printer is connected, the LPRINT command causes such a jump and the
message "CONNECT PRINTER" is displayed. If there is one connected, "Dear Sir"
is printed and the lines after the label are never run, because of the RETURN
before it.

</p><ul><li><b>You should always cancel ONERR with ONERR OFF as soon as an error has
      been detected.</b></li>
    <li><b>You should always deal with the LOW BATTERY error explicitly as it is
      so important.</b></li></ul>


<h3>ONERR OFF</h3>

<p>Notice that the first instruction after the label noprint:: is ONERR
OFF. This is very important because if you don't do this after the
ONERR label:: command is used, all subsequent program errors -
even in other procedures called - result in the program being directed
to the same label. This diagram illustrates how two completely
different errors cause a jump to the same label, and cause the same
explanatory message to be printed out:

</p><p class="program">proc1:
onerr label::
....
a=log(- 1)
....
label::
PRINT "Explanation of log error"
....
  <b>proc2:</b>
  ....
    <b>proc3:</b>
    PRINT 2/0</p>

<h3>Risks of ONERR label::</h3>

<p>As all errors go back to the same label unless you switch ONERR
OFF, it is very easy to create an endless loop by mistake. If this
happens, you cannot press <b>ON/CLEAR</b> and <b>Q</b> to break out, as this
just makes control go to the label as any other error would - so, you
have to take the battery out of the Organiser, and lose everything in
the internal memory. To avoid this:
</p><ul><li><b>You should always include the command ONERR OFF immediately after
      the label.</b></li></ul>


<a id="p7-7a"></a><h3>TRAP</h3>

<p>TRAP traps errors on a specified command only, so it doesn't need
to be cancelled like ONERR does. It can be used with any of the
commands listed below:

</p><p>APPEND BACK CLOSE COPY COPYW CREATE DELETE DELETEW ERASE
EDIT FIRST INPUT LAST NEXT OPEN POSITION RENAME UPDATE USE

</p><p>The trap command immediately precedes any of these commands, separated from
it by a space - e.g.:
<br><span class="code">TRAP INPUT a%</span>

</p><p>When INPUT is used without TRAP and a text string is entered
when a number is required, the display just scrolls up and a question
mark is shown, prompting for another - valid - entry. When you put
TRAP in front of INPUT, the command is executed in the usual way,
but if an error occurs the next line of the program is executed as if
there had been no error. The next line in the example below is a
helpful message.

</p><p class="program">proc:
LOCAL a%
start::
PRINT "ENTER AGE",
TRAP INPUT a%
IF ERR=252
 PRINT "NUMBER NOT WORD"
 GOTO start::
ENDIF</p>

<p>The example above also uses the ERR function.


<a id="p7-8a"></a></p><h3>The ERR function</h3>

<p>When errors occur in a program, the number of the error is accessible
by using the <b>ERR</b> function. This means that you can be absolutely
sure which error you are dealing with.

</p><p>The anticipated error in the lines below is 246 (NO PACK). If 246
occurs when trying to open the MAIN file on pack B: a helpful
error message is printed out. However, just in case a different error
occurs, the next lines make sure that the standard error message for
that error is printed.

</p><p class="program">TRAP OPEN "B:MAIN",A,a$
IF ERR=246
 PRINT "NO PACK IN B:"
ELSEIF ERR
 PRINT ERR$(ERR)
ENDIF</p>

<p>The OPL error messages are listed in <a href="https://www.jaapsch.net/psion/manlzpg.htm#D-1">Appendix D</a>.


<a id="p7-8b"></a></p><h3>RAISE</h3>

<p>If you are using commands to trap errors and handle them yourself,
then at some during the development stage of your program you need
to test your error handling routines. An easy way to do this is with the
RAISE command. You can generate an error that you think might
occur when the program is in use, and see if the error handling routine
takes care of it in the way you anticipate. For example, this statement
causes the NO PACK error to be generated:

</p><p class="program">RAISE 246</p>

<hr>

<a id="p8-1a"></a><h2>8 Example programs</h2>

<p>This chapter contains example programs written in OPL. The
programs are not intended to demonstrate all the features of OPL, but
they should give you a few hints. To find out more about a particular
command or function, refer to <a href="https://www.jaapsch.net/psion/manlzpg.htm#p9-1a">Chapter 9</a>. Each of the procedures must
be entered separately, you can't enter two procedures in one block.
<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-1a">Chapter 1</a> explains how to type in, translate, save and run a
procedure.


</p><p><b>Uppercase, lowercase</b>

</p><p>In the listings here, variables are shown in lowercase and commands
and functions in uppercase. However, it doesn't matter which you
use when you enter procedures into the Organiser:
</p><ul><li><b>You can type procedures in an uppercase, all lowercase or any mixture
      of the two.</b></li></ul>


<p><b>Spaces</b>

</p><p>Be careful to type in the necessary spaces:
</p><ul><li>When there is more than one command or function on a line, you
      need to separate each one with a space. Also each command or
      function except for the first must have a colon before it - for
      example:
      <br><span class="code">CLS :PRINT "hello" :GET</span></li>
    <li>Put a space between a command and the arguments which follow it - for
      example:
      <br><span class="code">LOCAL a$</span></li>
    <li>Don't put a space between a function and the arguments in brackets -
      for example:
      <br><span class="code">CHR$(16)</span></li>
    <li>It doesn't matter how many spaces you have at the beginning of a line.</li>
</ul>


<p><b>Remarks</b>

</p><p>Lines beginning with the command REM are remarks; they are there to explain
things. They do not affect the way a procedure runs and you don't have to
type them in if you don't want to.


</p><h3>1 Days (Version 1)</h3>

<p>This procedure works out the number of days you've been alive. Substitute
your own date of birth for the one supplied here.

</p><p class="program">days1:
LOCAL birth%,now%,answer%
birth%=DAYS(14,6,1957)
now%=DAYS(DAY,MONTH,YEAR)
answer%=now%-birth%
PRINT answer% :GET</p>

<p><b>Variables</b>
<br><b>birth%</b> is your date of birth.
<br><b>now%</b> is the current date.
<br><b>answer%</b> is the current date minus your date of birth.


</p><p><b>Date functions</b>
<br>All the OPL date functions return values accessed from the Organiser
clock and calendar. The function DAYS returns the number of days
since the beginning of the calendar on a particular date.


</p><h3>2 Days (Version 2)</h3>

<p>This procedure is a more flexible one which works out the number of days
between boy two dates that you input. When you run the procedure you are
prompted to enter the day, month and year of the first date then the
second date.

</p><p class="program">days2:
LOCAL d1%,m1%,y1%,d2%,m2%,y2%
PRINT "ENTER FIRST DAY"
INPUT d1%
PRINT "ENTER FIRST MONTH"
INPUT m1%
PRINT "ENTER FIRST YEAR"
INPUT y1%
PRINT "ENTER SECOND DAY"
INPUT d2%
PRINT "ENTER SECOND MONTH"
INPUT m2%
PRINT "ENTER SECOND YEAR"
INPUT y2%
PRINT DAYS(d2%,m2%,y2%)-DAYS(d1%,m1%,y1%)
GET</p>


<p><b>Variables</b>
<br><b>d1%</b>, <b>m1%</b> and <b>y1%</b> are the day month and year of the first date.
<br><b>d2%</b>, <b>m2%</b> and <b>y2%</b> are the day month and year of the second date.


</p><h3>3 Dice</h3>

<p>This procedure turns the Organiser into a dice. When the program is
run, a message is displayed saying that the dice is rolling. You then
press S to stop it. A random number from one to six is displayed and
you choose whether to roll again or not.

</p><p class="program">dice:
LOCAL dice%,key%
KSTAT 1
top::
CLS :PRINT "****DICE ROLLING****"
PRINT "PRESS S TO STOP"
DO
 dice%=(RND*6+1)
UNTIL KEY$="S"
CLS
PRINT "********* ";dice%;" ********"
BEEP 50,100
AT 1,4 :PRINT "ROLL AGAIN Y/N"
label::
key%=GET
IF key%=%Y
 GOTO top::
ELSEIF key%=%N
 RETURN
ELSE
 GOTO label::
ENDIF</p>


<p><b>Variables</b>
<br><b>dice%</b> is a random number from 1 to 6.
<br><b>key%</b> is the ASCII value of the keypress read by the GET function.


</p><p><b>Random numbers</b>
<br>This is how dice: displays 1, 2, 3, 4, 5 or 6 randomly. The RND
function returns a random floating point number, between 0 and 1
(not including 1). It is then multiplied by 6 and 1 is added (so that
you get numbers from 1 to 6 instead of from 0 to 5). It is rounded
down to a whole number by assigning to the integer dice%.


</p><p><b>Identifying keypresses of Y and N</b>
<br>The ASCII value of the character on the key you press is returned by
the GET function and assigned to key%. In OPL you get the ASCII
value of any character by putting % in front of it, so %Y is the ASCII
value of Y and %N is the ASCII value of N. In case you had the
keyboard set to lowercase, KSTAT 1 is used at the start of the
procedure to set it to uppercase, so that you are not pressing y and n.


</p><h3>4 Mortgage calculator</h3>

<p>This program calculates monthly mortgage payments. When you run
it, you have to enter the amount of the loan, the interest rate and the
term in years. Then you specify the source of the loan by selecting
from a menu. The program does not allow for tax relief.

</p><p>The program is made up to two procedures - mortgage: and q: - a
general input routine. You must type each one in separately. The
input routine could be called by any procedure which needs to
prompt the user to enter a floating point number.

</p><p class="program">mortgage:
LOCAL num%,loan,x,term,rate,pay,ques$(2)
CLS
PRINT "EVALUATE MONTHLY"
PRINT "MORTGAGE PAYMENT"
PAUSE 30
ques$=CHR$(63)+" "
REM CHR$(63) is a "?" - See <a href="https://www.jaapsch.net/psion/manlzpg.htm#A-1a">Appendix A</a>
loan=q:("ENTER LOAN"+ques$)
DO
 rate=q:("INTEREST RATE % "+ques$)
UNTIL rate&gt;0 AND rate&lt;99
DO
 term=q:("ENTER TERM (YRS)"+ques$)
UNTIL term&gt;.5 AND term&lt;100
num%=MENU("BUILDING-SOCIETY,BANK,OTHER")
IF num%=0 :RETURN :ENDIF
rate=rate/100 :x=1+11*(num%/2)
pay=loan*rate/12/(1-((1+rate/x)**(-x*term)))
CLS :PRINT "MONTHLY PAYMENT"
PRINT FIX$(pay, 2, -8)
GET
RETURN
<a id="p8-7a"></a>
q:(a$)
LOCAL z
CLS :PRINT a$,CHR$(16);
INPUT z
CLS
RETURN(z)</p>

<p><b>Variables</b>
<br><b>loan</b>, <b>term</b>, <b>rate</b> and <b>pay</b> are the amounts of
the loan, the term in years, the interest rate and the monthly payments.
<br><b>ques$</b> is "? ".
<br><b>num%</b> is the number of the menu item you choose.
<br><b>x</b> is a variable used in the calculation at the end.
<br><b>z</b> is the variable used for the values you input when q: is running.

</p><p><b>Calling q:</b>
<br>The main procedure mortgage: calls q: three times, passing it a string to
be printed out as a prompt. The text string is passed to q: as a parameter.
The values returned are assigned to the variables loan, rate, and term.

</p><p><b>How "?" is printed</b>
<br>The CHR$ function converts the ASCII value 63 to the question mark character.


</p><p><b>How the input routine beeps</b>
<br>The CHR$ function converts the value 16 to the beep control character. This
is then "printed" out.


<a id="p8-8a"></a></p><h3>5 Chase Game</h3>

<p>The next two procedures make up a game which demonstrates the use of user
defined graphics (UDG's). Each procedure must be typed in separately.

</p><p>The object of the game is to avoid being caught by the pursuers. Your
movable man can jump up and down: press the <b>X</b> key to jump down and the
<b>S</b> key to jump up. At the end of the game your score will be displayed
on the screen.

</p><p>To pause the game, press <b>ON/CLEAR</b> and to restart press it again. To quit
out of the game press <b>ON/CLEAR</b> then <b>Q</b>.

</p><p class="program">game:
LOCAL e$(2)
LOCAL a%,b%,b1%,c%,c1%,x%,y%,i%,sc%
graphic: :CURSOR OFF
e$=CHR$(4)+CHR$(6)
b%=20 :c%=12 :x%=3 :y%=1
DO
 CLS :PRINT REPT$(CHR$(158),80)
 AT x%,y% :PRINT CHR$(7)
 a%=1 :c%=1+RND*4
 DO :c1%=1+RND*4 :UNTIL c%&lt;&gt;c1%
 DO
  AT a%,c% :PRINT CHR$(0)
  AT a%,c1% :PRINT CHR$(0) :BEEP b%,10*b%
  AT a%,c% :PRINT CHR$(1)
  AT a%,c1% :PRINT CHR$(1) :BEEP b%,10*b%
  AT a%,c% :PRINT CHR$(2)
  AT a%,c1% :PRINT CHR$(2) :BEEP b%,10*b%
  AT a%,c% :PRINT CHR$(3)
  AT a%,c1% :PRINT CHR$(3) :BEEP b%,10*b%
  AT a%,c% :PRINT e$
  AT a%,c1% :PRINT e$ :BEEP b%,10*b%
  AT a%,c% :PRINT CHR$(5)
  AT a%,c1% :PRINT CHR$(5) :BEEP b%,10*b%
  AT a%,c% :PRINT " " :AT a%,c1% :PRINT " "
  i%=KEY
  IF i%
   IF i%=%S AND y%&gt;1
    AT x%,y% :PRINT CHR$(158)
    y%=y%-1 :AT x%,y% :PRINT CHR$(7)
   ENDIF
   IF i%=%X AND y%&lt;4
    AT x%,y% :PRINT CHR$(158)
    y%=y%+1 :AT x%,y% :PRINT CHR$(7)
   ENDIF
  ENDIF
  a%=a%+1
  IF a%=x% AND (c%=y% OR c1%=y%) :REM Hit
   i%=0
   DO
    AT x%,y% :PRINT CHR$(170+i%)
    BEEP 10,100+i%
    i%=i%+1
    BEEP 10,100-i%
   UNTIL i%=30
   b%=b%+5 :a%=20 :x%=x%+2
   IF x%&gt;20
    CLS :PRINT "GAME OVER"
    PRINT "SCORE:",sc% :PAUSE 40
    WHILE KEY :ENDWH :REM Drain buffer
    GET :RETURN
   ENDIF
  ENDIF
 UNTIL a%=20
 sc%=sc%+1
 IF b%&gt;12
  b%=b%-2
 ELSEIF b%&lt;6
  IF b1%
   b%=b%-1 :b1%=0
  ELSE
   b1%=1
  ENDIF
 ELSE
  b%=b%-1
 ENDIF
UNTIL 0

graphic:
UDG 0,0,0,28,30,30,30,28,0
UDG 1,0,0,14,31,30,31,14,0
UDG 2,0,0,7,14,12,14,7,0
UDG 3,0,0,3,7,6,7,3,0
UDG 4,0,0,1,3,3,1,0,0
UDG 5,0,0,0,1,1,1,0,0
UDG 6,0,0,24,16,4,16,24,0
UDG 7,30,14,4,14,30,14,11,25</p>


<p><b>User defined graphics</b>
<br>The main procedure, game:, calls graphic: which then uses the UDG
command 8 times to set up the graphics characters used in the game.
The last UDG command is the one which sets up the little man. User
defined characters are explained in <a href="https://www.jaapsch.net/psion/manlzpg.htm#A-1a">Appendix A</a>.


<a id="p8-11a"></a></p><h3>6 Data file handling procedures</h3>

<p>The main procedure below creates a data file called addr on device A,
to contain names, addresses, post codes and telephone numbers. It is
followed by 4 other procedures which allow you to insert, search for,
alter and erase records in the file. When you run files:, a menu giving
you a choice of these options is displayed.

</p><p>Each of these 5 procedures must be typed in separately.

</p><p class="program">files:
LOCAL m%
IF NOT EXIST("A:addr")
 CREATE "A:ADDR",A,n$,ad1$,ad2$,ad3$,pc$,tel$
ELSE
 OPEN " A:ADDR",A,n$,ad1$,ad2$,ad3$,pc$,tel$
ENDIF
DO
 m%=MENU("INSERT,SEARCH,ALTER,ERASE,QUIT")
 IF m%=0 or m%=5 :STOP
 ELSEIF m%=1 :insert:
 ELSEIF m%=2 :search:
 ELSEIF m%=3 :alter:
 ELSEIF m%=4 :erase:
 ENDIF
UNTIL 0 :REM do loop forever

insert:
PRINT "ENTER NAME" :INPUT A.n$
CLS :PRINT "ENTER STREET" :INPUT A.ad1$
CLS :PRINT "ENTER TOWN" :INPUT A.ad2$
CLS :PRINT "ENTER COUNTY" :INPUT A.ad3$
CLS :PRINT "ENTER PCODE" :INPUT A.pc$
CLS :PRINT "ENTER TELNUM" :INPUT A.tel$
APPEND

search:
LOCAL recnum%,search$(30)
top::
FIRST :CLS :PRINT "FIND:";
TRAP INPUT search$
IF ERR=206
 RETURN
ENDIF
recnum%=FIND(search$)
IF recnum%=0
 CLS :PRINT "NOT FOUND" :PAUSE 20
 GOTO top::
ENDIF
DO
 DISP(-1,"") :NEXT :recnum%=FIND(search$)
 IF recnum%=0 :CLS
  PRINT " NO MORE ENTRIES"
  PAUSE 20 :RETURN
 ENDIF
UNTIL 0

alter:
LOCAL recnum%,search$(30),k%
DO
 FIRST :CLS
 PRINT "ALTER:"; :TRAP INPUT search$
 IF ERR=206 :RETURN :ENDIF
 recnum%=FIND(search$)
 IF recnum%=0
  CLS :PRINT "NOT FOUND"
  PAUSE 20 :CONTINUE
 ENDIF
 DO
  KSTAT 1 :CLS :AT 1,2 :PRINT "EDIT Y/N"
  k%=VIEW(1,A.n$)
  IF k%=%Y :CLS
   EDIT A.n$ :EDIT A.ad1$
   EDIT A.ad2$ :EDIT A.ad3$
   EDIT A.pc$ :EDIT A.tel$ :UPDATE :RETURN
  ELSEIF k%=%N :NEXT :recnum%=FIND(search$)
   IF recnum%=0
    CLS :PRINT "NOT FOUND" :PAUSE 20 :BREAK
   ENDIF
  ENDIF
 UNTIL 0
UNTIL 0

erase:
LOCAL recnum%,search$(30),k%
FIRST :CLS :PRINT "ERASE:";
TRAP INPUT search$
IF ERR=206 :RETURN :ENDIF
recnum%=FIND(search$)
DO
 IF recnum%=0
  CLS :PRINT "NOT FOUND" :PAUSE 20 :RETURN
 ENDIF
 ask::
 KSTAT 1 :AT 1,2 :PRINT "ERASE Y/N"
 k%=VIEW(1,A.n$)
 IF k%&lt;&gt;%Y AND k%&lt;&gt;%N
  GOTO ask::
 ELSEIF k%=%Y
  ERASE
 ELSEIF k%=%N
  NEXT :recnum%=FIND(search$)
 ENDIF
UNTIL EOF</p>

<p><b>Variables</b>
<br><b>m%</b> is the number of the menu item you select
<br><b>recnum%</b> is the record number returned by FIND.
<br><b>search$</b> is the search clue you enter.
<br><b>k%</b> is the ASCII value of the key you press whilst the found record is
displayed. (%Y is the ASCII value of Y, %N is the ASCII value of N.)

</p><p><b>Creating the data file</b>
<br>The first procedure, files:, creates or opens a file called addr on device
A: with 6 fields for each record. The six field names are n$ for the
name, ad1$, ad2$, and ad$3 for each line of the address, pc$ for the
post code and tel$ for the phone number. The file is given the logical
name A.

</p><p><b>Inserting records</b>
<br>Notice how in insert: the 6 fields of the record are input one by one.
The field names are used like variables and preceded by the logical file
name (A) and a full stop. Then the APPEND command is used; this
is necessary to actually add the record to the end of the file.

</p><p><b>Displaying the current record</b>
<br>When a record containing a particular string has been found by
FIND it becomes the current record. DISP with -1 as the first
parameter, displays it.

</p><p>In the procedure alter:, VIEW is used to display just the first field of
the record, while you decide whether to edit it. If you choose to, each
field is then displayed by the EDIT function, which allows you to
alter what is on the screen.


<a id="p8-15a"></a></p><h3>7 Telephone logging (data file handling)</h3>

<p>These 3 procedures make up a program which allows you to log telephone
calls. It stores their duration with your comments in a data file. It could
easily be adapted to record the duration of any other activity.

</p><p>The first procedure displays a menu like this with a phone UDG and the
clock. Because the clock uses UDGs 3, 4, 5, 6, 7 and 1, UDGs 0 and 2 been
used for the phone and the underline:

</p><p><span class="screen"><u>X             11:19a</u>
Logcall   Viewcalls&nbsp;
                   &nbsp;
                   &nbsp;</span>


</p><p class="program">logger:
LOCAL m%
UDG 0,31,21,14,10,31,31,0,31
UDG 2,0,0,0,0,0,0,0,31
PRINT CHR$(0);REPT$(CHR$(2),14)
CLOCK(1)
m%=MENUN(2,"Logcall,Viewcalls")
IF m%=0
  RETURN
ELSEIF m%=1
  logcall:
ELSE m%=2
  viewcall:
ENDIF</p>

<p class="program">logcall:
LOCAL k%,h%,m%,s%,sec%,start$(8),swof%
ESCAPE OFF
IF NOT EXIST("A:LOG")
 CREATE "A:LOG",B,date$,t$,comment$
ELSE
 OPEN "A:LOG",B,date$,t$,comment$
ENDIF
swof%=PEEKB($7C)
POKEB $007C,0 :REM no auto turn off
B.t$="00:00:00"
B.date$=DATIM$
start$=RIGHT$(DATIM$,8)
h%=0 :m%=0 :s%=0 :sec%=SECOND
DO
 IF sec%&lt;&gt;SECOND
  BEEP 1,100
  sec%=SECOND :s%=s%+1
  IF s%=60 :s%=0 :m%=m%+1
   IF m%=60 :m%=0 :h%=h%+1
   ENDIF
  ENDIF
  B.t$=REPT$("0",-(h%&lt;10))+NUM$(h%,2)+":"
  B.t$=B.t$+REPT$("0",-(M%&lt;10))+NUM$(m%,2)+
  B.t$=B.t$+REPT$("0",-(s%&lt;10))+NUM$(s%,2)
 ENDIF
 AT 1,1 :PRINT "Started:";start$
 PRINT "Time:";B.t$
 PAUSE -1 :REM save battery
 k%=KEY
 IF k%=1
  GOTO exit::
 ENDIF
UNTIL k%=13
PRINT "Comments "+CHR$(63)
TRAP INPUT B.comment$
IF ERR=206
 GOTO exit::
ENDIF
CLS :PRINT "Saving" :APPEND
exit::
CLOSE
POKEB $007C,swof% :REM restore auto turn off
ESCAPE ON

viewcall:
LOCAL k%
TRAP OPEN "A:LOG",B,date$,t$,comment$
IF ERR :RETURN :ENDIF
DO
 k%=DISP (-1,"")
 NEXT
 IF k%=1
  RETURN
 ENDIF
UNTIL EOF
AT 1,4 :PRINT "  NO MORE ENTRIES"
PAUSE 25
RETURN</p>

<p><b>Variables</b>
<br><b>k%</b> is used for the keypresses read by KEY.
<br><b>sec%</b> is the actual number of seconds past the minute at the start of
the procedure.
<br><b>s%</b> is the seconds shown counting up.
<br><b>m%</b> is the minutes shown counting up.
<br><b>h%</b> is the minutes shown counting up.
<br><b>start$</b> is the time the call started.
<br><b>swof$</b> is the initial setting of auto-switch off.

</p><p><b>The data file</b>
<br>A data file called LOG is created on device A: with three fields in each
record: one for the date, one for the time which the call took, and one for
your comments. When you run the program and log a call the date, time and
comment are appended to the data file as a record. Select Viewcalls to look
through all the appended records.
<br>You could also open the file A LOG in Xfiles, and search for the records
using Find.

</p><p><b>How the stopwatch counts up the elapsed time</b>
<br>The actual number of seconds past the minute is read from the system clock
by the SECOND function and assigned to sec% at the start. Then the SECOND
function is used again, and if it is no longer equal to sec% - i.e. when a
second has elapsed - 1 is added to s% and sec% is assigned the actual number
of seconds again. Whenever s% is 60, it is reset to 0 and 1 is added to m%
and so on.

</p><p><b>ESCAPE OFF</b>
<br>Normally <b>ON/CLEAR</b> pauses the execution of a procedure so that <b>Q</b> can be
pressed to quit. At the start of this procedure ESCAPE OFF is used. This
means that <b>ON/CLEAR</b> does not pause the program, and can thus be read by
the KEY and DISP functions and cause a RETURN to the PROG menu instead of
an ESCAPE error.

</p><p><b>Displaying the records</b>
<br>When A:LOG is opened in viewcall, the first record is made current then
displayed by DISP with - 1 as the first parameter. Then NEXT is used to
make each record current in turn.


<a id="p8-19a"></a></p><h3>8 Diary file handling procedure</h3>

<p>If you save your diary to a file, you can use this program to copy all
the birthdays from one year to the next year. It could easily be
adapted to deal with other annual entries too.

</p><p>A saved diary file called "olddia" is opened. All the records
containing 1989 and birthday have the 1989 changed to 1990 and are put into a
file called "newdia". You can then restore "newdia" into
your current diary and merge the two.

</p><p>Remember to substitute the name of your saved diary for "olddia"
when you type the procedure in.

</p><p class="program">birthday:
CREATE "a:newdia",B,date$,text$
OPEN "a:olddia",A,date$,text$
WHILE FINDW("1989*birthday")
 PRINT a.text$
 b.date$="1990"+mid$(a.date$,5,255)
 b.text$=a.text$
 USE B :APPEND
 USE A :NEXT
ENDWH
GET</p>

<p><b>Diary files</b>
<br>A saved diary file is just like any other data file. However, for
more information about the format of records in diary files, see
<a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a">Chapter 6</a>.

</p><hr>

<a id="p9-1a"></a><h2>9 OPL commands and functions</h2>

<a id="p9-1b"></a><h3>Summary</h3>

<p>Here is a summary of the OPL commands and functions to give you
an idea of what is available. This is followed by an alphabetic list
which deals with each command and function in detail.

</p><p>A * indicates that the instruction can only be used on a model LZ
or LZ64 and not on an XP or CM.

</p><p><b>Structures</b>
</p><p><b>DO/UNTIL</b> Loops until a condition is met
<br><b>GOTO label::</b> Branches to a label
<br><b>IF/ELSEIF/ELSE/ENDIF</b> Acts conditionally
<br><b>WHILE/ENDWH</b> Loops while a condition is met
<br><b>BREAK</b> Exits from a loop
<br><b>CONTINUE</b> Goes to the test condition of a loop

</p><p><b>General commands</b>
</p><p><b>LOCATE</b> Positions the cursor
<br><b>BEEP</b> Sounds the buzzer
<br><b>CLS</b> Clears the display
<br><b>CURSOR</b> ON/OFF Sets the cursor
<br><b>EDIT</b> Allows a string to be edited on the screen
<br><b>ESCAPE ON/OFF</b> Allows user to break out of program
<br><b>GLOBAL</b> Declares variables for all procedures called
<br><b>INPUT</b> Allows data to be input
<br><b>KSTAT</b> Sets the keyboard status
<br><b>LOCAL</b> Declares variables for current procedure only
<br><b>OFF</b> Turns the Organiser off
<br><b>OFF x%</b> Turns the Organiser off for a limited time only*
<br><b>PAUSE</b> Pauses the program
<br><b>PRINT</b> Prints to the screen
<br><b>PRINT</b> Prints to an attached printer or computer,
<br><b>RANDOMIZE</b> Sets a new sequence of random numbers
<br><b>REM</b> Precedes a programmer's remark
<br><b>RETURN</b> Returns to the calling procedure
<br><b>STOP</b> Exits from OPL
<br><b>UDG</b> Defines a display character (user-defined graphic)*

</p><p><b>Error handling commands</b>
</p><p><b>ONERR label::</b> Goes to label on error
<br><b>ONERR OFF</b> Cancels ONERR label::
<br><b>RAISE</b> Generates an error
<br><b>TRAP</b> Traps errors on a specified command

</p><p><b>File handling commands</b>
</p><p><b>APPEND</b> Adds current field values to current data file
<br><b>CLOSE</b> Closes a data file
<br><b>COPY</b> Copies a data file
<br><b>COPYW</b> Copies any type of file*
<br><b>CREATE</b> Creates a data file
<br><b>DELETE</b> Deletes a data file
<br><b>DELETEW</b> Deletes any type of file*
<br><b>ERASE</b> Erases a record
<br><b>FIRST/LAST/NEXT/BACK</b> Select first/last/next/previous record
<br><b>OPEN</b> Opens a data file
<br><b>POSITION</b> Selects a record by number
<br><b>RENAME</b> Renames a data file
<br><b>UPDATE</b> Updates a record
<br><b>USE</b> Changes current data file

</p><p><b>Memory address commands</b>
</p><p><b>POKEB</b> Writes a byte to an address
<br><b>POKEW</b> Writes an integer to two successive addresses

</p><p><b>General functions</b>
</p><p><b>CHR$</b> Returns a character with a specified. ASCII code
<br><b>CLOCK</b> Displays the clock.*
<br><b>FIX$</b> Returns a number as a fixed point decimal
<br><b>FREE</b> Returns the amount of free internal memory
<br><b>GEN$</b> Returns a number as a string
<br><b>GET</b> Waits for a keypress. Returns ASCII value of key
<br><b>GET$</b> Waits for a keypress. Returns the key as a string
<br><b>KEY</b> Returns the ASCII value of the key pressed
<br><b>KEY$</b> Returns the key pressed as a string
<br><b>NUM$</b> Returns a number as an integer
<br><b>MENU</b> Displays a menu
<br><b>MENUN</b> Displays a multi-line menu*
<br><b>SPACE</b> Returns free memory space on a device
<br><b>VIEW</b> Displays a scrolling string on the screen

</p><p><b>Error handling functions</b>
</p><p><b>ERR</b> Returns error number
<br><b>ERR$</b> Returns error message

</p><p><b>File handling functions</b>
</p><p><b>COUNT</b> Returns the number of records in a data file
<br><b>DIR$</b> Returns name of data file
<br><b>DIRW$</b> Returns name of any type of file*
<br><b>DISP</b> Displays a record
<br><b>EOF</b> Tests for end of data file
<br><b>EXIST</b> Checks to see if a data file name exists
<br><b>FIND</b> Finds a record containing a string
<br><b>FINDW</b> Like FIND but allows the use of wild cards*
<br><b>POS</b> Returns the current record number
<br><b>RECSIZE</b> Returns bytes occupied by the current record

</p><p><b>Numeric functions</b>
</p><p><b>ABS</b> Returns the absolute (unsigned) value of a floating point number
<br><b>ACOS</b> Returns the arc cosine of a number*
<br><b>ASIN</b> Returns the arc sine of a number*
<br><b>ATAN</b> Returns the arc tangent of a number
<br><b>COS</b> Returns the cosine of a number
<br><b>DEG</b> Converts from radians to degrees
<br><b>EXP</b> Returns e raised to the power you specify
<br><b>FLT</b> Converts an integer into a floating point number
<br><b>IABS</b> Returns the absolute (unsigned) value of an integer
<br><b>INT</b> Returns a rounded down integer number
<br><b>INTF</b> As above, but returns a floating point number
<br><b>LN</b> Returns the natural log of a number
<br><b>LOG</b> Returns the base 10 log of a number
<br><b>PI</b> Returns pi (3.1415926535 ... )
<br><b>RAD</b> Converts from degrees to radians
<br><b>RND</b> Returns a random floating point number
<br><b>SIN</b> Returns the sine of a number.
<br><b>SQR</b> Returns the square root of a number
<br><b>TAN</b> Returns the tangent of a number
<br><b>HEX$</b> Converts an integer into a hexadecimal string

</p><p><b>Numeric list functions*</b>
</p><p><b>MAX</b> Returns the greatest item
<br><b>MIN</b> Returns the smallest item
<br><b>MEAN</b> Returns the mean
<br><b>STD</b> Returns the standard variation
<br><b>SUM</b> Returns the sum
<br><b>VAR</b> Returns the variance

</p><p><b>Date functions</b>
</p><p><b>DAYS</b> Returns the number of days since 0 1/ 0 1 1900 - used to fInd out
the number of days between two dates*
<br><b>DATIM$</b> Returns the date and time as a string
<br><b>DAYNAME$</b> Converts 1-7 to the day of the week*
<br><b>DOW</b> Returns the day a date falls on as a number 1-7*
<br><b>MONTH$</b> Converts 1- 12 to the month*
<br><b>SECOND/MINUTE/HOUR/DAY/MONTH/YEAR</b> Return Information
about the current time and date.
<br><b>WEEK</b> Returns the week number a date falls in*

</p><p><b>String handling functions</b>
</p><p><b>ASC</b> Returns the ASCII value of the first character of a string
<br><b>LEFT$/MID$/RIGHT$</b> Select characters from strings according to their
position
<br><b>LEN</b> Returns the length of a string
<br><b>LOC</b> Returns the location of a string within a string
<br><b>LOWER$/UPPER$</b> Convert a string to lower/upper case
<br><b>REPT$</b> Returns repetitions of a specified string
<br><b>VAL</b> Converts a numeric string to a floating point value

</p><p><b>Memory address functions</b>
<br><b>ADDR</b> Returns the address of a variable
<br><b>PEEKB</b> Returns the value stored at an address
<br><b>PEEKW</b> Returns the value store at two consecutive addresses

</p><p><b>Microprocessor functions</b>
<br><b>USR</b> Passes values to the microprocessor and returns an integer
<br><b>USR$</b> Passes values to the microprocessor and returns a string


<a id="p9-6a"></a></p><h3>Command syntax</h3>

<p>Most OPL commands require one or more arguments after them.
The arguments may be either literal values or variables.

</p><p>The following method of specifying the syntax of a command is used:

</p><table summary="">
<tbody><tr><td><b>x</b></td><td>Numeric expression, variable or literal. E.g. price or 49.99</td></tr>
<tr><td><b>x%</b></td><td>Integer expression in the range -32768 to +32767, variable or literal. E.g. price% or 50</td></tr>
<tr><td><b>a$</b></td><td>String expression, variable or literal. E.g. price$ or "49.99"</td></tr>
<tr><td><b>dev:</b></td><td>Device (A:, B: or C:)</td></tr>
<tr><td><b>log</b></td><td>Logical file name (A, B, C or D).</td></tr>
</tbody></table>

<ul><li>The arguments follow the command after a space and are separated
      by commas.</li>
    <li>So an example of the AT command - which has the syntax:
      <br><b>AT x%,y%</b>
      <br>might be
      <br><b>AT 15,2</b></li>
    <li>If you want more than one command or function on one line, you must
      separate them by a space followed by a colon - for example:
      <br><b>CLS :PRINT "hello"</b></li></ul>


<a id="p9-7a"></a><h3>Function syntax</h3>

<p>Functions are used to produce values which can then be assigned to a
variable or combined with commands such as PRINT. For example:
</p><p class="indent">The instruction y%=YEAR assigns the integer value 1990 (or whatever the
    current year is) to the variable y%</p>
<p class="indent">The instruction PRINT YEAR displays the number 1990 on the screen</p>

<p>The method of specifying the syntax is the same as for commands.

</p><p>You can tell what the return type of the function is by the type of the
receiving variable shown in the syntax:
</p><p class="indent">Numeric functions which return a floating point value look like this: f=FUNCTION.</p>
<p class="indent">Numeric functions which return an Integer look like this: f%=FUNCTION.</p>
<p class="indent">String functions look like this: f$=FUNCTION$.</p>

<ul><li>The arguments follow the function with no space, separated by commas
     and enclosed in round brackets ().</li>
    <li>So an example of an instruction including the ABS function which has
      the syntax:
      <br><b>a=ABS(x)</b>
      <br>might be
      <br><b>PRINT ABS(-10) or x=ABS(y)</b></li>
    <li>Commands, functions and arguments can be typed in upper or lower case.</li></ul>

<a id="p9-8a"></a><h3>List of commands and functions</h3>

<a id="ABS"></a><p><b>ABS</b>
<br>Syntax: <b>a=ABS(x)</b>
<br>Returns the absolute value, i.e. without any sign, of a floating point
number. E.g. <span class="code">ABS(-10)</span> is 10.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#IABS">IABS</a>.

<a id="ACOS"></a></p><p><b>ACOS</b>
<br>Syntax: <b>a=ACOS(x)</b>
<br>Returns the arc cosine of the expression inside the brackets.

<a id="ADDR"></a></p><p><b>ADDR</b>
<br>Syntax: <b>a%=ADDR(var)</b>
<br>Returns the address at which the variable inside the brackets is stored
in memory. You can use an array as the variable, e.g.
<span class="code">A%=ADDR(ARRAY())</span>, but
you can't specify individual elements of an array.

<a id="APPEND"></a></p><p><b>APPEND</b>
<br>Syntax: <b>APPEND</b>
<br>Appends the current field values to the end of the current file as a
new record.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#UPDATE">UPDATE</a>.

<a id="ASC"></a></p><p><b>ASC</b>
<br>Syntax: <b>a%=ASC(a$)</b>
<br>Returns the ASCII value of the first character of a string expression.
E.g. <span class="code">A%=ASC("hello")</span> returns 104.
<br>See <a href="https://www.jaapsch.net/psion/manlzpg.htm#A-1a">Appendix A</a> for the ASCII codes.

</p><p>If you just need the ASCII code for one particular character you can use
the % sign. For example, <span class="code">A%=%G</span> returns the ASCII
code for the letter G to the variable A%.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#CHR_">CHR$</a>.

<a id="ASIN"></a></p><p><b>ASIN</b>
<br>Syntax: <b>a=ASIN(x)</b>
<br>Returns the arc sine of the expression inside the brackets.

<a id="AT"></a></p><p><b>AT</b>
<br>Syntax: <b>AT x%,y%</b>
<br>Positions the cursor at the screen position you specify. x% is the number
of characters across the screen in the range 1 to 20, and y% (1, 2, 3 or 4)
indicates the top, second, third or bottom line.

<a id="ATAN"></a></p><p><b>ATAN</b>
<br>Syntax: <b>a=ATAN(x)</b>
<br>Returns the arc tangent of the expression inside the brackets.

<a id="BACK"></a></p><p><b>BACK</b>
<br>Syntax: <b>BACK</b>
<br>Makes the previous record in the current data file the current record. If
the current record is the first record in the file then the current record
does not change.

<a id="BEEP"></a></p><p><b>BEEP</b>
<br>Syntax: <b>BEEP x%,y%</b>
<br>Sounds the internal buzzer of the Organiser. The sound duration is k%
milliseconds. The frequency of the sound is determined by the equation
Frequency = 921600/(78+2*y%)Hz.

</p><p>Alternatively, the control character 16 can be used in conjunction with the
PRINT command and the CHR$ function to sound the buzzer, i.e.:
<span class="code">PRINT CHR$(16)</span>

<a id="BREAK"></a></p><p><b>BREAK</b>
<br>Syntax: <b>BREAK</b>
<br>Allows program control to break out of a DO/UNTIL or a WHILE/ENDWH loop,
and
to continue the execution of the program at the instruction following the
terminator of the loop (UNTIL or ENDWH).

<a id="CHR_"></a></p><p><b>CHR$</b>
<br>Syntax: <b>a$=CHR$(x%)</b>
<br>Returns the ASCII character with the value of the expression inside the
brackets. You can use it to print characters unavailable from the keyboard -
for example, the instruction <span class="code">PRINT CHR$(63)</span> prints
the question mark character. See <a href="https://www.jaapsch.net/psion/manlzpg.htm#A-1a">Appendix A</a> for more information.

<a id="CLOCK"></a></p><p><b>CLOCK</b>
<br>Syntax: <b>c%=CLOCK(x%)</b>
<br>This function displays the continuously updating clock in the top
right-hand corner of the screen. x% can be 0 or 1:
</p><table summary="">
  <tbody><tr><td>0</td><td>Clock not displayed or if CLOCK(1) has been used already, not updated.</td></tr>
  <tr><td>1</td><td>Clock displayed.</td>
</tr></tbody></table>
<p>Returns the previous status of the clock (0 or 1).

<a id="CLOSE"></a></p><p><b>CLOSE</b>
<br>Syntax: <b>CLOSE</b>
<br>Closes the current file.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#OPEN">OPEN</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#CREATE">CREATE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#DELETE">DELETE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#USE">USE</a>.

<a id="CLS"></a></p><p><b>CLS</b>
<br>Syntax: <b>CLS</b>
<br>Clears the screen, and returns the cursor to the first character space on
the top line.

<a id="CONTINUE"></a></p><p><b>CONTINUE</b>
<br>Syntax: <b>CONTINUE</b>
<br>Returns program control to the test expression of either a DO/UNTIL or
a WHILE/ENDWH loop. E.g.:

</p><p class="program">DO
  &lt;statement list&gt;
  IF x=y
    CONTINUE
  ENDIF
  &lt;statement list&gt;
UNTIL a=b</p>

<p>In the example, the CONTINUE command will be executed if the expression
following the IF statement is true. If this happens, program control will
then be transferred to the UNTIL test.

<a id="COPY"></a></p><p><b>COPY</b>
<br></p><table summary=""><tbody><tr><td valign="top">Syntax:</td>
<td><span class="code"><b>COPY "dev1:fname1","dev2:fname2"
COPY "dev1:fname1","dev2:"
COPY "dev1:","dev2:"</b></span></td></tr></tbody></table>
Copies data files from one device to another. There are three variations:

<p><b>1</b> In the first example, a data file on one device is copied to a file on
another device with a different filename. An example might be:
<br><span class="code">COPY "A:CLIENTS","B:CLIENT88"</span>
<br>If there is already a file on the destination device with the name fname2,
then the records in the file being copied over are appended to it. Otherwise
a new file is created with that name and the records written to it.

</p><p><b>2</b> In the second example, the file name on the destination device is taken
to
be the same as that on the source device.

</p><p><b>3</b> In the third example, all files on the source device are copied onto the
destination device, and are given the same names on the destination device
as they had on the source device.

<a id="COPYW"></a></p><p><b>COPYW</b>
<br></p><table summary=""><tbody><tr><td valign="top">Syntax:</td>
<td><span class="code"><b>COPYW "dev1:fname1.ext","dev2:fname2"
COPYW "dev1:fname1.ext","dev2:"
COPYW "dev1:*.*","dev2:"</b></span></td></tr></tbody></table>
Copies any type of file from one device to another. The three variations are
the same as for COPY except that you use file extensions to indicate the
type of file. You can also use wild cards. If the first name contains wild
cards, the second name must only be the device. E.g. to copy all the notepads
from B: to C: <span class="code">COPYW "B:*.NTS","C:"</span>
You must either specify an extension or .* on the first name, so to copy all
files of any type whose names end in 8 from A: to B:
<span class="code">COPYW "A:*8.*","B:"</span> Extensions are in <a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a">Chapter 6</a>.

<a id="COS"></a><p><b>COS</b>
<br>Syntax: <b>c=COS(x)</b>
<br>Returns the cosine of the expression inside the brackets. The expression
represents an angle expressed in radians.

<a id="COUNT"></a></p><p><b>COUNT</b>
<br>Syntax: <b>c%=COUNT</b>
<br>Returns the number of records in the current file.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#POS">POS</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#POSITION">POSITION</a>.

<a id="CREATE"></a></p><p><b>CREATE</b>
<br>Syntax: <b>CREATE "dev:fname",log,fld1,fld2</b>
<br>Creates a data file on device dev:, with the name fname, the logical file
name log, and up to 16 fields as specified by fld1, fld2 etc. The logical
file name (A, B, C or D) is used to refer to this file within the program.
Each new file is automatically OPEN, and up to four may be open at once.
An example of the command might be:
<br><span class="code">CREATE "A: CLIENTS", B, NAME$, PHONE$, ADDRESS$</span><br>
In this example a data file is created on device A: with the name clients
and the logical name B. Each record In this data file can have up to three
fields.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#OPEN">OPEN</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#CLOSE">CLOSE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#DELETE">DELETE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#USE">USE</a>.

<a id="CURSOR"></a></p><p><b>CURSOR ON/OFF</b>
<br>Syntax: <b>CURSOR ON</b> or <b>CURSOR OFF</b>
<br>Switches the cursor on or off. The default is CURSOR OFF.

<a id="DATIM_"></a></p><p><b>DATIM$</b>
<br>Syntax: <b>d$=DATIM$</b>
<br>Returns the current date and time fro m the system clock in string
format; e.g.: "MON 16 OCT 1989 16:25:30"
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#SECOND">SECOND</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#MINUTE">MINUTE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#HOUR">HOUR</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#DAY">DAY</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#MONTH">MONTH</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#YEAR">YEAR</a>.

<a id="DAY"></a></p><p><b>DAY</b>
<br>Syntax: <b>d%=DAY</b>
<br>Returns the current day of the month, 1 to 31).
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#SECOND">SECOND</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#MINUTE">MINUTE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#HOUR">HOUR</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#MONTH">MONTH</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#YEAR">YEAR</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#DATIM_">DATIM$</a>.

<a id="DAYNAME_"></a></p><p><b>DAYNAME$</b>
<br>Syntax: <b>d$=DAYNAME$(X%)</b>
<br>Converts x%, a number from 1 to 7, to the day of the week.
E.g.: <span class="code">d$=DAYNAME$(1)</span> returns Mon.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#DOW">DOW</a>.

<a id="DAYS"></a></p><p><b>DAYS</b>
<br>Syntax: <b>d%=DAYS(day%,month%,year%)</b>
<br>Returns the number of days since 01/01/1900. You can use this to find out the
number of days between two dates by subtracting one result from another. E.g.:
</p><p class="program">x%=DAYS(1,1,1989)
y%=DAYS(DAY,MONTH,YEAR)
z%=y%-x%</p>

<a id="DEG"></a><p><b>DEG</b>
<br>Syntax: <b>d=DEG(x)</b>
<br>Converts from radians to degrees. Returns the value of the expression in the
brackets, an angle measured in radians, as a number of degrees.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#RAD">RAD</a>.

<a id="DELETE"></a></p><p><b>DELETE</b>
<br>Syntax: <b>DELETE "dev:fname"</b>
<br>Deletes a data file with the name fname from device dev:. For example,
<span class="code">DELETE "B:CLIENTS"</span>. The file must be
closed before this command is given.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#CREATE">CREATE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#OPEN">OPEN</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#CLOSE">CLOSE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#USE">USE</a>.

<a id="DELETEW"></a></p><p><b>DELETEW</b>
<br>Syntax: <b>DELETEW "dev:fname.ext"</b>
<br>Deletes any type of file with the name fname from device dev:. The syntax
is the same as for DELETE except that you must use a file extension to
indicate the type of file. You can also use wild cards. E.g. to delete all
the notepad files on C:<br><span class="code">DELETEW "C:*.NTS"</span><br>
For details of the file extensions, see <a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a">Chapter 6</a>.

</p><p>Because DELETEW is such a powerful command, all files should be closed when
it is used. If they are not, the command will close them automatically.

<a id="DIR_"></a></p><p><b>DIR$</b>
</p><table summary=""><tbody><tr><td valign="top">Syntax:</td>
<td><b>d$=DIR$("dev")<br>
d$=DIR$("")</b></td></tr></tbody></table>
Returns the name of a data file:
<p><b>1</b> DIR$(dev:) returns the name of the first data file on the device
specified. The device name (A, B or C) must be in quotation marks and
brackets. E.g.: <span class="code">D$=DIR$ ("A")</span>
</p><p><b>2</b> Subsequent uses of this function with a null string in the brackets
return the names of the following files on the device. When there are no more,
a null string is returned.

<a id="DIRW_"></a></p><p><b>DIRW$</b>
</p><table summary=""><tbody><tr><td valign="top">Syntax:</td>
<td><b>d$=DIRW$("dev:fname.ext"')<br>
d$=DIRW$("")</b></td></tr></tbody></table>
Returns the name of any type of file. It works in the same way as DIR$,
except that you must specify a filename and extension as well as the device.
You can also use wild cards. E.g.: To return the name of the first notepad
on B: <span class="code">D$=DIRW$ ("B: *.NTS")</span>
<br>See <a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a">Chapter 6</a> for file extensions.

<a id="DISP"></a><p><b>DISP</b>
<br>Syntax: <b>d%=DISP(x%,a$)</b>
<br>Displays a string or a record according to the value of x%. The value of x%
may be - 1, 0 or 1:

</p><p><b>-1</b> a$ is ignored and the current record is displayed with one field
on each line of the display. The cursor keys may be used to scroll around the
record.
</p><p><b>1</b> a$ is displayed as above. If a$ contains tab characters (ASCII
character 9), these divide the string into different fields so the string
is displayed on different lines.
</p><p><b>0</b> a$ is ignored and the last displayed string or record is continued.
If any key other than the arrow keys is pressed, the number of that key is
returned.

</p><p>No other commands or functions should be used between using DISP with x%
equal to 1 or -1 and DISP with x% equal to 0. For example:

</p><p class="program">A%=DISP(1,A$)
WHILE A%&lt;&gt;13
  A%=DISP(0,"")
ENDWH</p>

<p>This displays A$ until <b>EXE</b> is pressed. Clearly there can be no reason to use
any other command or function which accesses the screen in between the two
uses of DISP. Doing so may have unpredictable results. (13 is the code for
the <b>EXE</b> key. See <a href="https://www.jaapsch.net/psion/manlzpg.htm#A-1a">Appendix A</a> for more details.)
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#VIEW">VIEW</a> and <a href="https://www.jaapsch.net/psion/manlzpg.htm#EDIT">EDIT</a>.

<a id="DO-UNTIL"></a></p><p><b>DO/UNTIL</b>
</p><table summary=""><tbody><tr><td valign="top">Syntax:</td>
<td><span class="code"><b>DO
 &lt;statement list&gt;
UNTIL x=y</b></span></td></tr></tbody></table>
The DO command is used to indicate the start of a list of one or more
statements which terminate with the UNTIL command. The list of statements
will be repeated until the expression after the UNTIL command returns
logical true.

<a id="DOW"></a><p><b>DOW</b>
<br>Syntax: <b>d%=DOW(day%,month%,year%)</b>
<br>Returns the day of the week of the date you specify as a number from 1
to 7. (Monday is 1.) E.g. <span class="code">D%=DOW(25,12,1990)</span>
returns 2, Tuesday.

<a id="EDIT"></a></p><p><b>EDIT</b>
<br>Syntax: <b>EDIT var$</b>
<br>Displays a string which you can edit on the screen using the cursor keys
and DEL. var$ can be a string variable name or a field name. When you have
finished editing, press <b>EXE</b> to return the edited string. If you press
<b>EXE</b>
before you have made any changes, then the same string will be returned as
was included inside the brackets. If you press ON/CLEAR during editing, the
string will be cleared and new text may be typed. However, if the TRAP
command is used with this command and ON/CLEAR is pressed twice, the string
will be cleared and then control will pass on to the next line of the
procedure with the ESCAPE error condition being set.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#DISP">DISP</a> and <a href="https://www.jaapsch.net/psion/manlzpg.htm#VIEW">VIEW</a>.

<a id="ELSE"></a></p><p><b>ELSE</b>
See <a href="https://www.jaapsch.net/psion/manlzpg.htm#IF">IF</a>.

<a id="ENDIF"></a></p><p><b>ENDIF</b>
See <a href="https://www.jaapsch.net/psion/manlzpg.htm#IF">IF</a>.

<a id="ENDWH"></a></p><p><b>ENDWH</b>
See <a href="https://www.jaapsch.net/psion/manlzpg.htm#WHILE-ENDWH">WHILE</a>.

<a id="EOF"></a></p><p><b>EOF</b>
<br>Syntax: <b>e%=EOF</b>
<br>Tests for the End Of File. Any program instruction which
tries to read past the last record in a data file will result in
the end of file (EOF) being reached. This can be tested for like this:
</p><p class="program">DO
  &lt;statement list&gt;
UNTIL EOF</p>
<p>The EOF function returns -1 (True) if the end of file condition has been
reached, or 0 (False).

<a id="ERASE"></a></p><p><b>ERASE</b>
<br>Syntax: <b>ERASE</b>
<br>Erases the current record in the current file. Following this command,
the current record will be the record after the one just deleted. If the
erased record was the last record in a file, then following this
command, the current record will be null and EOF will return true.

<a id="ERR"></a></p><p><b>ERR</b>
<br>Syntax: <b>e%=ERR</b>
<br>Returns the number of the last error which occurred. <a href="https://www.jaapsch.net/psion/manlzpg.htm#D-1">Appendix D</a> has a list of
all the error messages in numeric order. The number returned will be in the
range 0 to 255. If 0 is returned, there is no error.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#ERR_">ERR$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#RAISE">RAISE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#ONERR">ONERR</a>.

<a id="ERR_"></a></p><p><b>ERR$</b>
<br>Syntax: <b>e$=ERR$(x%)</b>
<br>Returns an error message as a string. x% can either be a number - e.g.
<span class="code">E$=ERR$(240)</span>, to return the message for error
number 240, or ERR - i.e. <span class="code">PRINT ERR$(ERR)</span>, to print
the message for the last error which occurred. If the number is outside the
range 192 to 255, "UNKNOWN ERR" is returned.
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D-1">Appendix D</a> is a list of error messages.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#ERR">ERR</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#ONERR">ONERR</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#RAISE">RAISE</a>.

<a id="ESCAPE"></a></p><p><b>ESCAPE OFF/ESCAPE ON</b>
<br>Syntax: <b>ESCAPE OFF</b> or <b>ESCAPE ON</b>
<br>Disables and enables the <b>ON/CLEAR</b> key. You can normally press
<b>ON/CLEAR</b> to pause a running program, and then <b>Q</b> to quit.
ESCAPE
OFF cancels the use of the <b>ON/CLEAR</b> key to pause. ESCAPE ON lets the
<b>ON/CLEAR</b> key pause the program again. This is the normal state.

</p><p><b>Warning:</b> If your program enters a loop which has no logical exit, and
ESCAPE OFF has been used, you won't be able to quit the program unless you
remove the battery from the Organiser. All data in the RAM of the machine
will then be lost.

<a id="EXIST"></a></p><p><b>EXIST</b>
<br>Syntax: <b>c%=EXIST("dev:fname")</b>
<br>Tests for the existence of a data file called fname on device dev:. Returns
logical true if the file exists and logical false otherwise - so EXIST can
be used on an IF statement, for example:
</p><p class="program">IF EXIST ("a:clients")
  &lt;statement list&gt;
ENDIF</p>
<p>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#DIR_">DIR$</a>.

<a id="EXP"></a></p><p><b>EXP</b>
<br>Syntax: <b>e=EXP(x)</b>
<br>Returns the value of the arithmetic constant e (2.71828... raised to
the power of x.

<a id="FIND"></a></p><p><b>FIND</b>
<br>Syntax: <b>f%=FIND(a$)</b>
<br>Searches the current data file for the string Inside the brackets. If found,
it returns the record number where the string occurs, and makes the record
the current record. If the string is not found, zero is returned.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#NEXT">NEXT</a>.

<a id="FINDW"></a></p><p><b>FINDW</b>
<br>Syntax: <b>f%=FINDW(a$)</b>
<br>Searches the current data file for the string inside the brackets in the
same way as FIND. The difference is that you can include wild cards in the
string expression. For example, to find a record containing both "Dr" and
either "BROWN" or "BRAUN", the instruction is:
<br><span class="code">F%=FINDW("*DR*BR++N")</span>

<a id="FIRST"></a></p><p><b>FIRST</b>
<br>Syntax: <b>FIRST</b>
<br>Makes the first record in a data file the current record.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#ERASE">ERASE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#NEXT">NEXT</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#POSITION">POSITION</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#LAST">LAST</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#BACK">BACK</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#POS">POS</a>.

<a id="FIX_"></a></p><p><b>FIX$</b>
<br>Syntax: <b>f$=FIX$(x,y%,z%)</b>
<br>Returns a string representation of x, with y% decimal places in a field
which is z% characters wide. If z% Is negative then the string is right
justified. So:
<span class="code">FIX$(123456.127,2,9)                ="123456.13"
FIX$(1,2,-5)                        =" 1.00"</span>
<br>If the number will not fit in the field width specified then the returned
string will contain asterisks.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#GEN_">GEN$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#NUM_">NUM$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#SCI_">SCI$</a>.

<a id="FLT"></a></p><p><b>FLT</b>
<br>Syntax: <b>f=FLT(x%)</b>
<br>Converts the integer expression inside the brackets into a floating point
number.

<a id="FREE"></a></p><p><b>FREE</b>
<br>Syntax: <b>f%=FREE</b>
<br>Returns the number of free bytes in the work area.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#SPACE">SPACE</a>.

<a id="GEN_"></a></p><p><b>GEN$</b>
<br>Syntax: <b>g$=gen$(x,y%)</b>
<br>Returns a string representation of x in a field of width y% characters.
GEN$ tries to represent the number as integer, decimal or scientific,
in that order. If the value of y% is negative then the result will be right
justified. If the number will not fit in the field width specified then the
returned string will contain asterisks.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#FIX_">FIX$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#NUM_">NUM$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#SCI_">SCI$</a>.

<a id="GET"></a></p><p><b>GET</b>
<br>Syntax: <b>g%=GET</b>
<br>Waits for a key to be pressed and returns the ASCII value or special code
for that key. For example, if the A key is pressed in lower case mode, the
integer returned is 97. If the <b>EXE</b> key is pressed, the integer returned
is 13. See <a href="https://www.jaapsch.net/psion/manlzpg.htm#A-1a">Appendix A</a> for tables of ASCII values and special key codes.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#GET_">GET$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#KEY">KEY</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#KEY_">KEY$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#PAUSE">PAUSE</a>.

<a id="GET_"></a></p><p><b>GET$</b>
<br>Syntax: <b>g$=GET$</b>
<br>Waits for a key to be pressed and returns that key as a string. For example,
if the A key is pressed in lower case mode, the string returned is "a".
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#GET">GET</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#KEY">KEY</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#KEY_">KEY$</a>.

<a id="GLOBAL"></a></p><p><b>GLOBAL</b>
<br>Syntax: <b>GLOBAL var1,var2%,var3$(length),var4(n)</b>
<br>Used to declare variables which will be available in the current procedure
and any procedures below it in the program.

</p><p>Variable names not ending with a special sign are floating point variables;
those ending with a percent sign (%) are integers; those ending with a
dollar sign ($) are string variables. String variable names must be followed
by the maximum length of the string in brackets.

</p><p>The last variable in the example above is a floating point array. The number
following it in brackets is the number of elements in the array. Array
variables may be of any of the three types.

</p><p>Variable names may be up to 8 alphanumeric characters long, the first of
which must be a letter. This length includes the % or $. More than one
GLOBAL or LOCAL statement may be used but they must be the first lines in
the procedure. See the chapter on variables for more information.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#LOCAL">LOCAL</a>.

<a id="GOTO"></a></p><p><b>GOTO</b>
<br>Syntax: <b>GOTO label::</b>
<br>Sends program control to the line containing the label name label:: The
label must be in the current procedure, and must end with a double colon.
Labels may be up to 8 characters long excluding the colons.

<a id="HEX_"></a></p><p><b>HEX$</b>
<br>Syntax: <b>h$=HEX$(x%)</b>
<br>Returns the hexadecimal (base 16) version of the integer expression inside
the brackets. For example: <span class="code">HEX$(255)</span> will return
"FF".

</p><p>(Hex numbers may be entered by preceding them by a $. So
<span class="code">PRINT $FF</span> gives 255.)

<a id="HOUR"></a></p><p><b>HOUR</b>
<br>Syntax: <b>h%=HOUR</b>
<br>Returns the number of the current hour from the system clock (0 to 23).
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#SECOND">SECOND</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#MINUTE">MINUTE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#DAY">DAY</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#MONTH">MONTH</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#YEAR">YEAR</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#DATIM_">DATIM$</a>.

<a id="IABS"></a></p><p><b>IABS</b>
<br>Syntax: <b>i%=IABS(x%)</b>
<br>Returns the absolute value, i.e. without any sign, of an integer.
E.g. <span class="code">IABS(-10)</span> is 10.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#ABS">ABS</a>.

<a id="IF"></a></p><p><b>IF/ELSEIF/ELSE/ENDIF</b>
</p><table summary=""><tbody><tr><td valign="top">Syntax:</td>
<td><span class="code"><b>IF x=y
 &lt;statement list&gt;
ELSEIF x=z
 &lt;statement list&gt;
ELSE
 &lt;statement list&gt;
ENDIF</b></span></td></tr></tbody></table>
IF statements are immediately followed by an expression. If the result of
that expression returns logical true, (non-zero) then the statements
following are executed. If the expression returns logical false (zero) then
those statements are ignored. The statement list must be followed by an
ENDIF.

<p>The ELSEIF statement is optional, but if it is included, and the following
expression returns logical true - while none of the previous ones have,
then the next list of statements are executed. There may be more than one
ELSEIF, each with its own list of statements.

</p><p>The ELSE statement is optional. If none of the preceding expressions have
returned logical true, then the list of statements after the ELSE statement
and before the ENDIF statement are executed.

<a id="INPUT"></a></p><p><b>INPUT</b>
</p><table summary=""><tbody><tr><td valign="top">Syntax:</td>
<td><span class="code"><b>INPUT var%
INPUT var
INPUT var$
INPUT log.field</b></span></td></tr></tbody></table>
<p>Allows data to be input from the keyboard during program execution. There
are four variations.
</p><p>The variable supplied must have been declared previously with a GLOBAL or
LOCAL command, or be a field variable of the current file. If inputting to a
string variable, you cannot exceed its maximum length.
</p><p>If inappropriate input is entered, e.g. a string when the variable specified
was an integer, a "?" is displayed and you can try again. However, if the
TRAP command is used with INPUT, control passes on to the next line of the
procedure with the ESCAPE error condition (no. 206) being set.

<a id="INT"></a></p><p><b>INT</b>
<br>Syntax: <b>i%=INT(x)</b>
<br>Returns the integer (i.e. the whole number part) of x. Negative numbers are
rounded down, so INT(-5.3) returns -6. Used when the returned value will be
within the Organiser's integer range.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#INTF">INTF</a>.

<a id="INTF"></a></p><p><b>INTF</b>
<br>Syntax: <b>i=INTF(x)</b>
<br>Used in the same way as the INT function, but the value returned is a
floating point number. You may need this when an integer calculation may
exceed the Organiser's integer range, for example:
<span class="code">PRINT INTF(320000/3)*100</span>

<a id="KEY"></a></p><p><b>KEY</b>
<br>Syntax: <b>k%=KEY</b>
<br>Returns the ASCII value of any key pressed. If no key has been pressed, zero
is returned. This command doesn't wait for a key to be pressed.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#PAUSE">PAUSE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#GET">GET</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#GET_">GET$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#KEY_">KEY$</a>.

<a id="KEY_"></a></p><p><b>KEY$</b>
<br>Syntax: <b>k$=KEY$</b>
<br>Returns a string containing the key pressed. If no key has been pressed, a
null string is returned. KEY$ does not wait for a key to be pressed.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#KEY">KEY</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#GET">GET</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#GET_">GET$</a>.

<a id="KSTAT"></a></p><p><b>KSTAT</b>
<br>Syntax: <b>KSTAT x%</b>
<br>Sets the state of the keyboard to SHIFT mode. CAPS mode etc. x% is a number
from 1 to 4:
<br>1&nbsp;&nbsp; Alphabetic - upper case
<br>2&nbsp;&nbsp; Alphabetic - lower case
<br>3&nbsp;&nbsp; Numeric - upper case
<br>4&nbsp;&nbsp; Numeric - lower case

<a id="LAST"></a></p><p><b>LAST</b>
<br>Syntax: <b>LAST</b>
<br>Makes the last record in a data file the current record.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#ERASE">ERASE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#FIRST">FIRST</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#NEXT">NEXT</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#POSITION">POSITION</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#BACK">BACK</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#POS">POS</a>.

<a id="LEFT_"></a></p><p><b>LEFT$</b>
<br>Syntax: <b>b$=LEFT$(a$,x%)</b>
<br>Returns the leftmost x% characters from the string specified by a$.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#RIGHT_">RIGHT$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#MID_">MID$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#LEN">LEN</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#LOC">LOC</a>.

<a id="LEN"></a></p><p><b>LEN</b>
<br>Syntax: <b>a%=LEN(a$)</b>
<br>Returns the length of the string expression a$.

<a id="LN"></a></p><p><b>LN</b>
<br>Syntax: <b>a=LN(x)</b>
<br>Returns the natural (base e) logarithm of the expression inside the brackets.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#LOG">LOG</a>.

<a id="LOC"></a></p><p><b>LOC</b>
<br>Syntax: <b>a%=LOC(a$,b$)</b>
<br>Returns the position in a$ where b$ occurs. E.g.
<span class="code">LOC("Standing","AND")</span> would
return the value 3 because the substring "AND" starts at the third
character of the main string. If b$ does not occur in a$, zero is returned.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#LEFT_">LEFT$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#RIGHT_">RIGHT$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#MID_">MID$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#LEN">LEN</a>.

<a id="LOCAL"></a></p><p><b>LOCAL</b>
<br>Syntax: <b>LOCAL var1%,var2,var3$(length),var4(n)</b>
<br>Used to declare variables which will only be available in the current
procedure. Other procedures may use the same variable names for other uses.
<br>See <a href="https://www.jaapsch.net/psion/manlzpg.htm#GLOBAL">GLOBAL</a> for more details on declaring variables.

<a id="LOG"></a></p><p><b>LOG</b>
<br>Syntax: <b>a=LOG(x)</b>
<br>Returns the base 10 logarithm of the expression inside the brackets.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#LN">LN</a>.

<a id="LOWER_"></a></p><p><b>LOWER$</b>
<br>Syntax: <b>b$=LOWER$(a$)</b>
<br>Converts any upper case characters in the string expression inside the
brackets to lower case and returns the completely lower case string.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#UPPER_">UPPER$</a>.

<a id="LPRINT"></a></p><p><b>LPRINT</b>
<br>Syntax: <b>LPRINT x,y%;a$</b>
<br>Prints out to a printer. If there is no printer attached, a DEVICE MISSING
error is reported. If the Psion Printer II is attached and you get this
message, try pressing <b>ON/CLEAR</b> on the main menu to load the printer
software.

</p><p>If items to be printed are separated by commas, there is a space between
them when printed. If they are separated by semi-colons, there are no
spaces.
<br>A final semi-colon makes the next items printed with an LPRINT command
start immediately after these. A final comma has the same effect but inserts
a space. Otherwise the next line is used. For example, the instruction:
<br><span class="code">LPRINT "The year is", YEAR</span>
<br>prints
<br><span class="screen">The year is 1989    </span>
</p><p>The PRINT command operates like LPRINT, but displays on the screen rather
than listing to a printer.

<a id="MAX"></a></p><p><b>MAX</b>
</p><table summary=""><tbody><tr><td valign="top">Syntax:</td>
<td><b>m=MAX(Item1,item2,item3)
<br>m=MAX(array(),n)</b></td></tr></tbody></table>
<p>Returns the greatest of the items in the list. The list can either be a list
of items separated by commas, or the elements of a floating point array.
For more details of the format of list functions, see <a href="https://www.jaapsch.net/psion/manlzpg.htm#MEAN">MEAN</a>.

<a id="MEAN"></a></p><p><b>MEAN</b>
</p><table summary=""><tbody><tr><td valign="top">Syntax:</td>
<td><b>m=MEAN(item1,item2,item3)
<br>m=MEAN(array(),n)</b></td></tr></tbody></table>
Returns the mean (average) of the items in the list. The list can either be
a list of items separated by commas, or the elements of a floating point
array.
<p><b>1</b> The items in the list can be any mixture of real values and integer and
floating point variables. E.g.:<br>
<span class="code">m=MEAN(12,x,y%,3.6)</span>
</p><p><b>2</b> When operating on an array, the two arguments in brackets are the
array name, and the number of array elements you wish to operate on. E.g.: to
return the mean of the first 3 elements of an array called arr,
<span class="code">m=MEAN(arr(),3)</span> In the example below, 12.5 would be
displayed:
</p><p class="program">LOCAL a(3)
a(1)=10
a(2)=15
a(3)=20
PRINT MEAN(a(),2)</p>

<a id="MENU"></a><p><b>MENU</b>
<br>Syntax: <b>m%=MENU(menuitem1,menuitem2...)</b>
<br>Displays a menu of items and allows a selection to be made from the menu in
the usual way. Returns the number of the item selected (1 to ... ). If
<b>ON/CLEAR</b> is pressed, 0 is returned.
</p><p>The menu items are displayed starting on the top line of the screen.

<a id="MENUN"></a></p><p><b>MENUN</b>
<br>Syntax: <b>m%=MENUN(n%,menuitem1,menuitem2...)</b>
<br>Displays a menu of items in the same way as MENU. However, the items are
displayed differently according to the value of n%:
</p><p>n%=0 Exactly the same as MENU
<br>n%=1 Displays a one-line menu
<br>n%=2 Displays a multi-line menu starting on the line with the current cursor
position. Any text already display on the line above the cursor remains on
the screen.

<a id="MID_"></a></p><p><b>MID$</b>
<br>Syntax: <b>m$=MID$(a$,x%,y%)</b>
<br>Returns a string comprising y% characters of a$, starting at the character
at position x%.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#LEFT_">LEFT$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#RIGHT_">RIGHT$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#LEN">LEN</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#LOC">LOC</a>.

<a id="MIN"></a></p><p><b>MIN</b>
</p><table summary=""><tbody><tr><td valign="top">Syntax:</td>
<td><b>m=MIN(item1,item2,item3)
<br>m=MIN(array(),n)</b></td></tr></tbody></table>
Returns the smallest of the items in the list. The list can either be a
list of items separated by commas, or the elements of a floating point array.
<br>For more details of the format of list functions, see <a href="https://www.jaapsch.net/psion/manlzpg.htm#MEAN">MEAN</a>.

<a id="MINUTE"></a><p><b>MINUTE</b>
<br>Syntax: <b>m%=MINUTE</b>
<br>Returns the current minute number from the system clock (0 to 59).
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#SECOND">SECOND</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#HOUR">HOUR</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#DAY">DAY</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#MONTH">MONTH</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#YEAR">YEAR</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#DATIM_">DATIM$</a>.

<a id="MONTH"></a></p><p><b>MONTH</b>
<br>Syntax: <b>m%=MONTH</b>
<br>Returns the current month from the system clock (1 to 12).
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#SECOND">SECOND</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#MINUTE">MINUTE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#HOUR">HOUR</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#DAY">DAY</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#YEAR">YEAR</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#DATIM_">DATIM$</a>.

<a id="MONTH_"></a></p><p><b>MONTH$</b>
<br>Syntax: <b>m$=MONTH$(x%)</b>
<br>Converts x% a number from 1 to 12 to the month.
E.g.: <span class="code">M$=MONTH$(1)</span> returns Jan.

<a id="NEXT"></a></p><p><b>NEXT</b>
<br>Syntax: <b>NEXT</b>
<br>Makes the next record the current record in the current file. If use of NEXT
is continued beyond the end of a file, no error is reported but the current
record is a null and the EOF function returns true.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#FIRST">FIRST</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#LAST">LAST</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#BACK">BACK</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#POSITION">POSITION</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#POS">POS</a>.

<a id="NUM_"></a></p><p><b>NUM$</b>
<br>Syntax: <b>n$=NUM$(x,y%)</b>
<br>Returns a string representation of the floating point number x as an
integer in a field y% characters wide. If y% is negative then the string is
right justified. If the number will not fit in the field width specified
then the returned string will contain asterisks.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#FIX_">FIX$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#GEN_">GEN$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#SCI_">SCI$</a>.

<a id="OFF"></a></p><p><b>OFF</b>
<br>Syntax: <b>OFF</b> or <b>OFF x%</b>
<br>Switches off the Organiser. If the ON/CLEAR key is pressed, program
execution will start again at the program line following the OFF command.
x% is a number from 1 to 1800. If you include this number the machine
switches off for that number of seconds only.

<a id="OPEN"></a></p><p><b>OPEN</b>
<br>Syntax: <b>OPEN "dev:fname",log,fld1,fld2</b>
<br>Opens an existing data file on device dev:, with the logical file name log,
with the field names as specified by fld1, fld2 etc. That file may then be
referred to within the program by the logical file name (A, B, C or D). Up
to 4 files can be open at once. For more details see the section on opening
a file in the data file handling chapter.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#CREATE">CREATE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#CLOSE">CLOSE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#DELETE">DELETE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#USE">USE</a>.

<a id="ONERR"></a></p><p><b>ONERR</b>
<br>Syntax: <b>ONERR label::</b> and <b>ONERR OFF</b>
<br>If an error occurs during program execution, the ONERR label:: instruction
transfers program control to the line containing the label.
</p><p>ONERR OFF cancels the ONERR label:: statement, so that any errors occurring
below the ONERR OFF statement are no longer referred to the label:: <b>It is
advisable to put the command ONERR OFF immediately after the label and to
test for LOW BATTERY explicitly.</b>

<a id="PAUSE"></a></p><p><b>PAUSE</b>
<br>Syntax: <b>PAUSE x%</b>
</p><p>Pauses the program according to the value of x%:
</p><table summary="">
<tbody><tr><td><b>0</b></td><td>Waits for a key to be pressed.</td></tr>
<tr><td><b>&lt;0</b></td><td>Pauses for x% (made positive) twentieths of a second or until a key is pressed.</td></tr>
<tr><td><b>&gt;0</b></td><td>Pauses for x% twentieths of a second.</td></tr>
</tbody></table>
<p>So PAUSE 100 would cause the program to pause for five seconds. In the
first two cases, the key pressed is stored in a buffer and it is wise to
remove it with the KEY function:
</p><p class="program">&lt;statement list&gt;
PAUSE 0
KEY
&lt;statement list&gt;</p>
The keypress stored in the buffer from the PAUSE 0 command is taken as the
input for KEY.

<a id="PEEKB"></a><p><b>PEEKB</b>
<br>Syntax: <b>P%=PEEKB(x%)</b>
<br>Returns the value (0 to 255) stored at the address specified by the
expression inside the brackets.

<a id="PEEKW"></a></p><p><b>PEEKW</b>
<br>Syntax: <b>p%=PEEKW(x%)</b>
<br>Returns the value of the two byte integer stored at addresses x% and x%+1.

<a id="PI"></a></p><p><b>PI</b>
<br>Syntax: <b>p=PI</b>
<br>Returns the value of Pi (3.14...).

<a id="POKEB"></a></p><p><b>POKEB</b>
<br>Syntax: <b>POKEB x%,y%</b>
<br>Writes the number y% which must be in the range 0 to 255, into the memory
address x%, which must be an integer. Addresses above 32767 are addressed by
negative values or hexadecimal numbers. E.g. $FFFF=-1, which corresponds to
address 65535.
<br><b>Warning: Casual use of this command can result in the loss of an data in
the Organiser.</b>

<a id="POKEW"></a></p><p><b>POKEW</b>
<br>Syntax: <b>POKEW x%,y%</b>
<br>Writes the integer y% into two successive memory addresses, starting with
the address x%, with the most significant byte in the lower address.
<br><b>Warning: Casual use of this command can result In the loss of an data in
the Organiser.</b>

<a id="POS"></a></p><p><b>POS</b>
<br>Syntax: <b>p%=POS</b>
<br>Returns the number of the current record in the current data file.

<a id="POSITION"></a></p><p><b>POSITION</b>
<br>Syntax: <b>POSITION x%</b>
<br>Makes record number x% the current record in the current data file. If x% is
greater than the number of records in the file then the EOF function will
return true.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#FIRST">FIRST</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#NEXT">NEXT</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#LAST">LAST</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#BACK">BACK</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#POS">POS</a>.

<a id="PRINT"></a></p><p><b>PRINT</b>
<br>Syntax: <b>PRINT x,y%;a$</b>
<br>Prints numbers or text to the screen.
</p><p>If items to be printed are separated by commas, there is a space between
them when displayed. If they are separated by semi-colons, there are no
spaces.
<br>A final semi-colon makes the next items displayed with a PRINT command start
immediately after these. A final comma has the same effect but inserts a
space. Otherwise the next line is used. For example, the instruction:
<br><span class="code">PRINT "The year is", YEAR</span>
<br>displays
<br><span class="screen">The year is 1989    </span>
</p><p>The LPRINT command operates in the same way as the PRINT command except
that
it prints on a printer.

<a id="RAD"></a></p><p><b>RAD</b>
<br>Syntax: <b>n=RAD(x)</b>
<br>Converts x from degrees to radians.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#DEG">DEG</a>.

<a id="RAISE"></a></p><p><b>RAISE</b>
<br>Syntax: <b>RAISE x%</b>
<br>Artificially generates an error, even though no such error has occurred.
If no ONERR statement has been issued previously then the appropriate
message for that error number Is displayed. The range of possible internal
errors to use as x% is 192 to 255. Refer to the chapter on error handling
for more explanation. A full list of error messages is in <a href="https://www.jaapsch.net/psion/manlzpg.htm#D-1">Appendix D</a>.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#ONERR">ONERR</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#ERR">ERR</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#ERR_">ERR$</a>.

<a id="RANDOMIZE"></a></p><p><b>RANDOMIZE</b>
<br>Syntax: <b>RANDOMIZE x</b>
<br>Gives a new seed value to the random number generator, so that a new
sequence of random numbers will be initiated. So use RANDOMIZE if you wish
to use the same sequence of random numbers more than once.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#RND">RND</a>.

<a id="RECSIZE"></a></p><p><b>RECSIZE</b>
<br>Syntax: <b>r%=RECSIZE</b>
<br>Returns the number of bytes occupied by the current record. No record may
contain more than 254 characters, so this function may be used to check that
a record may have data added to It without overstepping this limit.

<a id="REM"></a></p><p><b>REM</b>
<br>Syntax: <b>REM text</b>
<br>The REM statement precedes a remark you include to explain how a program
works. The Organiser ignores all text after the REM statement up to the end
of that line.

<a id="RENAME"></a></p><p><b>RENAME</b>
<br>Syntax: <b>RENAME "dev:fname1","fname2"</b>
<br>Renames a file on device dev: called fname1 as the file fname2. E.g.:
<span class="code">RENAME "B:ADDR", "OLDADDR"</span>

<a id="REPT_"></a></p><p><b>REPT$</b>
<br>Syntax: <b>r$=REPT$(a$,x%)</b>
<br>Returns a string comprising x% repetitions of a$.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#LEFT_">LEFT$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#RIGHT_">RIGHT$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#MID_">MID$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#UPPER_">UPPER$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#LOWER_">LOWER$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#LEN">LEN</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#LOC">LOC</a>.

<a id="RETURN"></a></p><p><b>RETURN</b>
<br>Syntax: <b>RETURN</b> or <b>RETURN x</b>
<br>Used on its own, the RETURN command terminates the execution of a procedure
and returns control to the point where that procedure was called. Use of
this command at the end of a procedure is optional.

</p><p>The RETURN command may also be used to pass a value back to the level from
which the procedure was called. The value must be supplied after the RETURN
command thus: <span class="code">RETURN X% or RETURN X or RETURN A$</span>

</p><p>A procedure may only return one type of value as indicated by the identifier
which is the last character of the procedure name. So proc$: can only return
a string.

<a id="RIGHT_"></a></p><p><b>RIGHT$</b>
<br>Syntax: <b>r$=RIGHT$(a$,x%)</b>
<br>Returns the rightmost x% characters of a$.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#LEFT_">LEFT$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#MID_">MID$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#REPT_">REPT$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#LEN">LEN</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#LOC">LOC</a>.

<a id="RND"></a></p><p><b>RND</b>
<br>Syntax: <b>r=RND</b>
<br>Returns a random floating point number in the range 0 (inclusive) to 1
(exclusive).
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#RANDOMIZE">RANDOMIZE</a>.

<a id="SCI_"></a></p><p><b>SCI$</b>
<br>Syntax: <b>s$=SCI$(x,y%,z%)</b>
<br>Returns a string representation of x In scientific format, to y% decimal
places in a field of width of z% characters. For example:
<br><span class="code">SCI$ (123456, 2, 8)         = "1.23E+05"
SCI$(1,2,8)                 = "1.00E+00"
SCI$(123456789,2,-9)        = "1.23E+08"</span>
<br>If the number does not fit in the field width specified then the returned
string contains asterisks.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#FIX_">FIX$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#GEN_">GEN$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#NUM_">NUM$</a>.

<a id="SECOND"></a></p><p><b>SECOND</b>
<br>Syntax: <b>SECOND</b>
<br>Returns the current number of seconds from the system clock (0 to 59).
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#MINUTE">MINUTE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#HOUR">HOUR</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#DAY">DAY</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#MONTH">MONTH</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#YEAR">YEAR</a>.

<a id="SIN"></a></p><p><b>SIN</b>
<br>Syntax: <b>s=SIN(x).</b>
<br>Returns the sine of the expression inside the brackets. The expression
represents an angle expressed in radians.

<a id="SPACE"></a></p><p><b>SPACE</b>
<br>Syntax: <b>s=SPACE</b>
<br>Returns the number of free bytes on the current device. There must be a file
open on the device first.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#FREE">FREE</a>.

<a id="SQR"></a></p><p><b>SQR</b>
<br>Syntax: <b>s=SQR(x)</b>
<br>Returns the square root of the expression inside the brackets.

<a id="STD"></a></p><p><b>STD</b>
</p><table summary=""><tbody><tr><td valign="top">Syntax:</td>
<td><b>s=STD(item1,item2,item3)
<br>s=STD(array(),n)</b></td></tr></tbody></table>
Returns the standard deviation of the items in the list. The list can either
be a list of items separated by commas, or the elements of a floating point
array. For more details of the format of list functions, see <a href="https://www.jaapsch.net/psion/manlzpg.htm#MEAN">MEAN</a>.

<a id="STOP"></a><p><b>STOP</b>
<br>Syntax: <b>STOP</b>
<br>Halts execution of the language and returns the Organiser to the point where
that program was started, e.g. the main menu or the calculator.

<a id="SUM"></a></p><p><b>SUM</b>
</p><table summary=""><tbody><tr><td valign="top">Syntax:</td>
<td><b>s=SUM(item1,item2,item3)
<br>s=SUM(array(),n)</b></td></tr></tbody></table>
Returns the sum of the items in the list. The list can either be a list of
items separated by commas, or the elements of a floating point array.
<br>For more details of the format of list functions, see <a href="https://www.jaapsch.net/psion/manlzpg.htm#MEAN">MEAN</a>.

<a id="TAN"></a><p><b>TAN</b>
<br>Syntax: <b>t=TAN(x)</b>
<br>Returns the tangent of the expression inside the brackets. The expression
represents an angle expressed in radians.

<a id="TRAP"></a></p><p><b>TRAP</b>
<br>Syntax: <b>TRAP command</b>
<br>TRAP may precede any of these commands:
<br>APPEND​/​BACK​/​CLOSE​/​COPY​/​COPYW​/​CREATE​/​DELETE​/​DELETEW​/​ERASE​/​EDlT​/​FIRST​/​INPUT​/​LAST​/​NEXT​/​OPEN​/​POSITION​/​RENAME​/​UPDATE​/​USE
<br>For example, <span class="code">TRAP FIRST</span>. Any error resulting
from the execution of the command will be trapped - the next program line
will be executed regardless of whether the error would normally have caused
an error message to be displayed.

<a id="UDG"></a></p><p><b>UDG</b>
<br>Syntax: <b>UDG x%,a%,b%,c%,d%,e%,f%,g%,h%</b>
<br>Defines a display character. x% is the number of the character (0-7) and the
integers a% to h% define each line of the character. For example, the
instruction:
<br><span class="code">UDG 7,0,0,0,0,0,0,0,31</span>
<br>Defines UDG 7 as an underline character.
<br>See <a href="https://www.jaapsch.net/psion/manlzpg.htm#A-1a">Appendix A</a> for a full explanation of this command.

<a id="UNTIL"></a></p><p><b>UNTIL</b>
See <a href="https://www.jaapsch.net/psion/manlzpg.htm#DO-UNTIL">DO</a>.

<a id="UPDATE"></a></p><p><b>UPDATE</b>
<br>Syntax: <b>UPDATE</b>
<br>The current record in the current file is deleted and the current field
values are appended as a new record at the end of the file.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#APPEND">APPEND</a>.

<a id="UPPER_"></a></p><p><b>UPPER$</b>
<br>Syntax: <b>u$=UPPER$(a$)</b>
<br>Converts any lower case characters in the string expression inside the
brackets to upper case. Returns the completely upper case string.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#LOWER_">LOWER$</a>.

<a id="USE"></a></p><p><b>USE</b>
<br>Syntax: <b>USE log</b>
<br>Selects for use the data file with the logical file name log (A, B, C or D),
which must previously have been opened with OPEN or CREATE command.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#OPEN">OPEN</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#CLOSE">CLOSE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#CREATE">CREATE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#DELETE">DELETE</a>.

<a id="USR"></a></p><p><b>USR</b>
<br>Syntax: <b>u%=USR(x%,y%)</b>
<br>The value of y% is passed to the D register and the value of x% is passed to
the PC register of the HD6303X microprocessor. The microprocessor then
executes the machine language program starting at the address x%. At the end
of the routine, the value in the X register is passed back to the language as
an integer.
<br><b>Warning: Casual use of this function can result in the loss of all data in
the Organiser.</b>
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#USR_">USR$</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#ADDR">ADDR</a>.

<a id="USR_"></a></p><p><b>USR$</b>
<br>Syntax: <b>u$=USR$(x%,y%)</b>
<br>The value of y% is passed to the D register and the value of x% is passed
to the PC register of the HD6303X microprocessor. The microprocessor then
executes the machine language program starting at the address x%. At the end
of the routine, the value in the X register must point to a length-byte
preceded string. This string is then returned.
<br><b>Warning: Casual use of this function can result in the loss of all data
in the Organiser.</b>
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#USR">USR</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#ADDR">ADDR</a>.

<a id="VAL"></a></p><p><b>VAL</b>
<br>Syntax: <b>v=VAL(a$)</b>
<br>Returns a floating point number which is the value of the string expression
inside the brackets. E.g. <span class="code">VAL ("470.0")</span>
would return the value 470.0. The string cannot contain any non-numeric
characters. ScientifIc notation is allowed, so
<span class="code">VAL("1.3E10")</span> would return the value 1.3E10.

<a id="VAR"></a></p><p><b>VAR</b>
</p><table summary=""><tbody><tr><td valign="top">Syntax:</td>
<td><b>v=VAR(item1,item2,item3)
<br>v=VAR(array(),n)</b></td></tr></tbody></table>
Returns the variance of the items in the list. The list can either be a
list of items separated by commas, or the elements of a floating point
array.
<br>For more details of the format of list functions, see <a href="https://www.jaapsch.net/psion/manlzpg.htm#MEAN">MEAN</a>.

<a id="VIEW"></a><p><b>VIEW</b>
<br>Syntax: <b>v%=VIEW(x%,a$)</b>
</p><p>Displays a$ on line number x% (1, 2, 3 or 4) on the screen. a$ can be
a string, a string variable, or a field name.

</p><p>If the text is longer than 20 characters, the display auto-scrolls to the
left, and pressing the left or right cursor keys allows you to change the
direction of the scroll. Pressing any other key halts the scrolling of the
text and returns the ASCII value of the key pressed. If VIEW is used again
with a$ being a null string then viewing is continued at the point it was
interrupted by a key press.
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#DISP">DISP</a>.

<a id="WEEK"></a></p><p><b>WEEK</b>
<br>Syntax: <b>w%=WEEK(day%,month%,year%)</b>
<br>Returns the week number of the date you specify. The weeks begin on Mondays,
so the 1st Monday in January is the beginning of week 1.

<a id="WHILE-ENDWH"></a></p><p><b>WHILE/ENDWH</b>
</p><table summary=""><tbody><tr><td valign="top">Syntax:</td>
<td><span class="code"><b>WHILE x&lt;&gt;y
 &lt;statement list&gt;
ENDWH</b></span></td></tr></tbody></table>
<p>This structure is started by the WHILE command which precedes a numeric
expression.
</p><p>The subsequent list of statements, which must end with the ENDWH
statement, is executed while the expression returns logical true (non-zero).
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#DO-UNTIL">DO/UNTIL</a>.

<a id="YEAR"></a></p><p><b>YEAR</b>
<br>Syntax: <b>y%=YEAR</b>
<br>Returns the current year from the system date (1900 to 2155).
<br>See also <a href="https://www.jaapsch.net/psion/manlzpg.htm#SECOND">SECOND</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#MINUTE">MINUTE</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#HOUR">HOUR</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#DAY">DAY</a>, <a href="https://www.jaapsch.net/psion/manlzpg.htm#MONTH">MONTH</a>.

</p><hr>

<a id="A-1a"></a><h2>Appendix A</h2>

<h3>Organiser character set</h3>

<p>The full character set of the Organiser is shown in the table
overleaf. The more common characters can obviously just be typed
from the keyboard. However, there are others which do not appear
on the keys. These are accessed via the OPL CHR$ function.


<a id="A-1b"></a></p><h4>Printing non-keyboard characters</h4>

<p>By supplying the CHR$ function with the appropriate number from
the table overleaf, you can print out to the screen or the printer, or
assign to string variables, any of the characters shown. For example,
to display a question mark the instruction is:
<br><span class="code">PRINT CHR$(63)</span>
<br>To display a pound sign the instruction is:
<br><span class="code">PRINT CHR$(156)</span>

</p><h4><b>Finding out the ASCII code of a keyboard character</b></h4>

<p>You can find out the ASCII value of any of the characters on the
keyboard at any time without looking at the table. You do this by
typing the % sign followed by the character in the calculator. For
example if you type %P in the calculator, the number 80 is returned.

</p><div align="center"><img src="./LZ_LZ64 Programming Manual - Jaap&#39;s Psion Organiser II Page_files/charslz1.gif" width="511" height="625" alt="Character Set, part 1"></div>

<p>The table on these two pages shows the characters which have the
ASCII codes 32 to 255. 32 is the space character.
</p><p>The codes 0 to 7 are for user-defined characters. (page A-6)
</p><p>The codes 8 to 31 are for control characters. (page A-5)

</p><div align="center"><img src="./LZ_LZ64 Programming Manual - Jaap&#39;s Psion Organiser II Page_files/charslz2.gif" width="511" height="625" alt="Character Set, part 2"></div>


<a id="A-4a"></a><h4>Accessing ASCII values within procedures</h4>

<p>It is often useful to access the ASCII value of a character in a
procedure - for example if you want to know whether a user has typed in Y
or N.

</p><p>To do this you can use the % sign and the character, e.g. %Y. The example
below is part of a procedure in which you are asked whether or not you want
to erase something. If you type N the program stops. If you type Y another
procedure called erase: is called. If you type a key other than Y or N the
procedure goes to a label in order to give you another chance.

</p><p class="program">PRINT "ERASE Y/N"
label::
g%=GET
IF g%=%N OR g%=%n :STOP
ELSEIF g%=%Y OR g%=%y :erase:
ELSE GOTO label::
ENDIF</p>


<a id="A-4b"></a><h4>Codes for special keys</h4>

<p>When functions such as the GET and KEY functions are used, the ASCII code
for the character on the key is normally returned. The keys not in the ASCII
set return these numbers:

</p><table summary="">
<tbody><tr><td><b>ON/CLEAR</b></td><td>1</td></tr>
<tr><td><b>MODE</b></td><td>2</td></tr>
<tr><td><b>UP</b></td><td>3</td></tr>
<tr><td><b>DOWN</b></td><td>4</td></tr>
<tr><td><b>LEFT</b></td><td>5</td></tr>
<tr><td><b>RIGHT</b></td><td>6</td></tr>
<tr><td><b>SHIFT and DEL</b></td><td>7</td></tr>
<tr><td><b>DEL</b></td><td>8</td></tr>
<tr><td><b>EXE</b></td><td>13</td></tr>
</tbody></table>


<a id="A-5"></a><h4>Control characters</h4>

<p>For the screen, the numbers 8 to 26 have special uses. They do not
produce a visible character, but may be used in conjunction with the
PRINT command produce the effects listed below. For example, the
instruction PRINT CHR$(22) clears the 3rd line of the screen.

</p><p>CHR$(8) Moves the cursor 1 character to the left.
<br>CHR$(9) Moves the cursor to the next tab position. (Position 0 and 10 on the
screen.)
<br>CHR$(10) Moves the cursor to the next line.
<br>CHR$(11) Moves the cursor to the top left "home" position of the
display.
<br>CHR$(12) Clears the display (equivalent to CLS).
<br>CHR$(13) Moves the cursor to the left of the current line.
<br>CHR$(14) Clears the top line of the display, and moves cursor to start of line.
<br>CHR$(15) Clears the second line of the display, and moves cursor to start of line.
<br>CHR$(16) Sounds the Organiser's buzzer.
<br>CHR$(17) Refreshes the 1st and 2nd line.
<br>CHR$(18) Refreshes the 1st line.
<br>CHR$(19) Refreshes the 2nd line.
<br>CHR$(20) Refreshes the 3rd line.
<br>CHR$(21) Refreshes the 4th line.
<br>CHR$(22) Clears the 3rd line of the display, and moves cursor to start of line.
<br>CHR$(23) Clears the 4th line of the display, and moves cursor to start of line.
<br>CHR$(24) Prints dashes, like the ones above a multi-line menu, on the 2nd line.
(uses UDG 2.)
<br>CHR$(25) Prints dots, like the ones above a one-line menu, on the 3rd line. (uses
UDG 2.)
<br>CHR$(26) Clears to the end of line.
<br>
<br>CHR$(27) to CHR$(31) are reserved.


<a id="A-6"></a></p><h4>User-defined characters</h4>

<p>For the screen, the numbers 0 to 7 are reserved for user-defined characters.
You use the UDG command to define the pattern of dots which appears when you
print one of these characters with the CHR$ function.

</p><p>You define each character line-by-line by a series of eight bytes, starting
with the top line of the character. (From each of the eight bytes which make
up the characters, only the last five bits 16 to 1 are used because the
characters are only five dots across.)

</p><div align="center"><img src="./LZ_LZ64 Programming Manual - Jaap&#39;s Psion Organiser II Page_files/udg.gif" width="477" height="424" alt="UDG"></div>

<p>To define the running man as character number 1, you would use the
instruction below. The first number is the character number and the 8
numbers after represent each line of the character.

</p><p><span class="code">UDG 1,30,14,4,14,30,14,11,25</span>

</p><p>Then you can use this instruction to display the man:

</p><p><span class="code">PRINT CHR$(1)</span>

<a id="A-7"></a></p><p>The screen clock, the symbols in the top left-hand corner, and the dotted
lines under and over menus, all use UDGs. So, each time they are displayed,
they overwrite any UDGs you have defined. You therefore have to redefine
your UDGs each time you wish to display them.

</p><p>This shows the UDG numbers taken up by the clock, the symbol and the
underline graphics.

</p><p><span class="code">02            345671</span><br>
<span class="screen"><u>X             12:45a</u>
Edit   New    Run  &nbsp;
Print  Dir    Copy &nbsp;
Delete             &nbsp;</span>

</p><p>If you wish to display an underlined menu with a symbol and the clock, you
have to use UDGs 0 and 2 for your symbol and the underline. The telephone
logging program in <a href="https://www.jaapsch.net/psion/manlzpg.htm#p8-15a">Chapter 8</a> is an example of how to do this.

</p><hr>

<a id="B-1"></a><h2>Appendix B</h2>
<h3>Technical Data</h3>

<p><b>Dimensions (with protective case closed)</b>
</p><table summary="">
  <tbody><tr><td>Length</td><td>142.0 mm</td></tr>
  <tr><td>Width</td><td>78.0 mm</td></tr>
  <tr><td>Depth</td><td>29.3 mm</td></tr>
  <tr><td>Weight</td><td>250 grams.</td></tr>
</tbody></table>


<p><b>Display</b>
<br>Four line by twenty character alphanumeric dot-matrix liquid crystal display.

</p><p><b>Keyboard</b>
<br>A total of thirty six keys including editing, cursor, alphabetic, numeric,
<b>MODE</b> and <b>ON/CLEAR</b>.

</p><p><b>Microprocessor</b>
<br>HD6303X Crystal frequency 3.6864 Mhz.

</p><p><b>Memory</b>
<br>ROM: 64K
<br>RAM: 32K LZ, 64K LZ64
<br>Extra EPROM 8/16/32/64/128K - from Datapaks.
<br>Extra RAM 32K - from Rampak.

</p><p><b>Clock</b>
<br>Real time clock with 32768 Hz crystal frequency source.


<a id="B-2"></a></p><h4>Datapaks</h4>

<p><b>Storage medium</b>
<br>EPROM (Erasable, Programmable. Read Only Memory)

</p><p><b>Data retention</b>
<br>'Mean time to failure' 50 years at temperatures up to 100'C

</p><p><b>Formatting</b>
<br>30 minutes in Psion Formatter clears Datapak. Can be re-formatted up
to 100 times

</p><p><b>Memory capacity</b>
</p><table summary=""><tbody><tr>
  <td>8K Datapak</td>
  <td>8192 bytes</td>
</tr><tr>
  <td>16K Datapak</td>
  <td>16384 bytes</td>
</tr><tr>
  <td>32K Datapak</td>
  <td>32768 bytes</td>
</tr><tr>
  <td>64K Datapak</td>
  <td>65536 bytes</td>
</tr><tr>
  <td>128K Datapak</td>
  <td>131072 bytes</td>
</tr></tbody></table>

<h4>Datapaks</h4>

<p><b>Storage medium</b>
<br>Battery backed-up RAM.

</p><p><b>Formatting</b>
<br>Format option in Utils clears Rampak.

</p><p><b>Memory capacity</b>
<br>32768 bytes.

</p><h4>Power</h4>

<p>Standard alkaline 9 volt long-life battery. Mains adaptor available.
</p><p>Psion has a policy of continuous product development Small modifications
arising from this are not necessarily reflected in this manual.

</p><hr>

<a id="C-1"></a><h2>Appendix C</h2>
<h3>Technical programming</h3>

<h4>Memory addresses</h4>

<p>These addresses are used for certain system variables. You access them with
PEEKB, PEEKW, POKEB and POKEW. You should only use these commands if you
know what you are doing.

</p><table summary=""><tbody><tr>
  <td>Address</td>
  <td>Default</td>
  <td>Use</td>
</tr><tr>
  <td>$0069,$006A</td>
  <td>($04)</td>
  <td>Horizontal scroll delay counter</td>
</tr><tr>
  <td>$006B,$006C</td>
  <td>($0A)</td>
  <td>Vertical scroll delay counter</td>
</tr><tr>
  <td>$0077</td>
  <td>($0E)</td>
  <td>Delay before keyboard auto-repeat</td>
</tr><tr>
  <td>$0078</td>
  <td>($00)</td>
  <td>Keyboard auto-repeat counter</td>
</tr><tr>
  <td>$007C</td>
  <td>non-zero</td>
  <td>Auto-switch off flag, 0 disables</td>
</tr><tr>
  <td>$20CB,$20CC</td>
  <td></td>
  <td>Frame counter, increments every 50ms</td>
</tr><tr>
  <td>$20CD,$20CE</td>
  <td>($012C)</td>
  <td>Default number of seconds to auto-switch off</td>
</tr><tr>
  <td>$00A4</td>
  <td>($00)</td>
  <td>Buzzer mute. Non-zero mutes</td>
</tr><tr>
  <td>$2099</td>
  <td>($F5)</td>
  <td>Border character round 2-line mode procedure.</td>
</tr><tr>
  <td>$20C0</td>
  <td>($01)</td>
  <td>Length of key click. 0 is silent</td>
</tr><tr>
  <td>$20A7</td>
  <td>($1F)</td>
  <td>Sets bits for workday alarms.
    The default is $1F - Monday to Friday:
<br><span class="code">MSB                         LSB
       1       |       F
 0   0   0   1 | 1   1   1   1
    Sun Sat Fri Thu Wed Tue Mon</span></td>
</tr></tbody></table>


<h4>Memory Map</h4>

<p>The Organiser Model LZ has 64K of ROM and 32K of RAM in the following
arrangement. Model LZ64 has two extra 16K RAM banks as indicated.

</p><div align="center"><img src="./LZ_LZ64 Programming Manual - Jaap&#39;s Psion Organiser II Page_files/memory.gif" width="656" height="606" alt="Memory map"></div>


<a id="C-3a"></a><h4>Hexadecimal numbers</h4>

<p>To get a hexadecimal number in OPL, prefix it with a $ identifier - for
example $FF is 255.

<a id="C-3b"></a></p><h4>Machine language programming</h4>

<p>The Organiser's CPU (Central Processor Unit) is the HD6303X microprocessor.
This advanced processor can be programmed directly, in its own language
called machine language or machine code.

</p><p>Machine language programs run far faster than OPL programs and take up
less memory, but they are much more difficult to write and debug. Also, a
simple mistake in a machine language program can easily wipe out all of the
information stored in the internal memory of the Organiser, as these
programs take over full control of the chip at the heart of the machine.

</p><p>To avoid this, it is wise to save all important data to a pack before
testing machine language programs, so that all will not be lost if the
machine loses all its data, or 'crashes'.

</p><hr>

<a id="D-1"></a><h2>Appendix D</h2>
<h3>Error messages</h3>

<p>The error messages are listed in numeric order. If you find it difficult
to locate a message because you do not know the number, find what
page it's on by looking it up in the index. Error trapping is covered in
<a href="https://www.jaapsch.net/psion/manlzpg.htm#p7-1a">Chapter 7</a>.

<a id="D192"></a></p><p><b>192 DEVICE WRITE FAIL</b>
<br>Usually occurs when a pack is faulty or when an attempt is made to write to
a write-protected program pack. Also occurs when an attempt is made to format
a Datapak rather than a Rampak in the Utils Format option or when Comms Link
fails.

<a id="D193"></a></p><p><b>193 DEVICE READ FAIL</b>
<br>Usually occurs when a pack is faulty or when trying to copy from a
copy-protected pack or when Comms Link fails.

<a id="D194"></a></p><p><b>194 BATTERY TOO LOW</b>
<br>The battery is low. Switch off and see Chapter 1 of the operating manual on
how to change the battery.

<a id="D195"></a></p><p><b>195 INTEGER OVERFLOW</b>
<br>The range of numbers allowed for integer variables (-32768 to +32767) has
been exceeded.

<a id="D196"></a></p><p><b>196 FILE NOT OPEN</b>
<br>An attempt has been made to write to or read from a file which is not open.

<a id="D197"></a></p><p><b>197 BAD PROC NAME</b>
<br>Occurs when an invalid procedure name is given. For instance, in New in Prog
or inserted in the main menu.

<a id="D198"></a></p><p><b>198 RECORD TOO BIG</b>
<br>No record may exceed a total of 254 characters.

<a id="D199"></a></p><p><b>199 FILE IN USE</b>
<br>An attempt has been made to open a file which is already open, or to delete
a file which is open.

<a id="D200"></a></p><p><b>200 READ PACK ERROR</b>
<br>The data in a Datapak cannot be read and the pack needs re-formatting.

<a id="D201"></a></p><p><b>201 FIELD MISMATCH</b>
<br>Occurs when a field variable used does not match any of those in the current
file.

<a id="D202"></a></p><p><b>202 MENU TOO BIG</b>
<br>The string supplied to the MENU function is too large and must be shortened.

<a id="D203"></a></p><p><b>203 MISSING PROC</b>
<br>A procedure has been called which does not exist on any device.

<a id="D204"></a></p><p><b>204 MISSING EXTERNAL</b>
<br>A variable has been encountered which has not been declared in a calling
procedure as a global variable and has not been declared in the current
procedure as a local or global variable.

<a id="D205"></a></p><p><b>205 ARG COUNT ERR</b>
<br>An incorrect number of arguments has been supplied to a procedure.

<a id="D206"></a></p><p><b>206 ESCAPE</b>
<br>The ON/CLEAR key followed by Q has been pressed during program execution,
halting that program.

<a id="D207"></a></p><p><b>207 BAD FIELD LIST</b>
<br>Any file must contain at least one and not more than sixteen fields. Occurs
when an attempt is made to exceed these limits.

<a id="D208"></a></p><p><b>208 BAD ASSIGNMENT</b>
<br>An attempt has been made to assign a value to the wrong type of variable -
for example by the statement a$=4.3

<a id="D209"></a></p><p><b>209 BAD LOGICAL NAME</b>
<br>An illegal logical name has been used: i.e., not A B, C or D.

<a id="D210"></a></p><p><b>210 MISSING COMMA</b>
<br>A comma has been omitted from a list of items which should be delimited
by commas throughout.

<a id="D211"></a></p><p><b>211 MISSING LABEL</b>
<br>An attempt been made to GOTO a label which does not exist in the current
procedure.

<a id="D212"></a></p><p><b>212 TOO COMPLEX</b>
<br>Structures within a procedure have been nested too deeply. The limit is 8.

<a id="D213"></a></p><p><b>213 STRUCTURE ERR</b>
<br>An IF/ENDIF. WHILE/ENDWH or DO/UNTIL structure has been incorrectly
nested.

<a id="D214"></a></p><p><b>214 DUPLICATE NAME</b>
<br>The file, procedure or variable name given is already in existence on the
current device.

<a id="D215"></a></p><p><b>215 BAD ARRAY SIZE</b>
<br>An array has been declared with an illegal number of elements,
e.g. GLOBAL name$(0,15)

<a id="D216"></a></p><p><b>216 BAD DECLARATION</b>
<br>A variable has been declared incorrectly - e.g. GLOBAL name$(300) - where the
length of the string exceeds the maximum allowed.

<a id="D217"></a></p><p><b>217 NO PROC NAME</b>
<br>An externally created program file has been introduced which does not have a
valid procedure name as its first line.

<a id="D218"></a></p><p><b>218 BAD NUMBER</b>
<br>A number which cannot be evaluated properly has been used. E.g. 2.3.4

<a id="D219"></a></p><p><b>219 BAD CHARACTER</b>
<br>A non-valid character such as ? or @ has been included in a calculation
string or an expression.

<a id="D220"></a></p><p><b>220 STRING TOO LONG</b>
<br>A string has been produced which exceeds the space allocated with the GLOBAL
or LOCAL commands. E.g.:
</p><p class="program">LOCAL a$(10)
A$="123456789ABCDEF"</p>

<a id="D221"></a><p><b>221 MISMATCHED "</b>
<br>Occurs when quotation marks are not paired up correctly.

<a id="D222"></a></p><p><b>222 BAD IDENTIFIER</b>
<br>An incorrectly formed variable name has been used, e.g. name$$.

<a id="D223"></a></p><p><b>223 NAME TOO LONG</b>
<br>The specified file, procedure or variable name exceeds the maximum number
of characters allowed: eight characters including the $ or % qualifier.

<a id="D224"></a></p><p><b>224 TYPE MISMATCH</b>
<br>A value has been assigned to variable of the wrong type, e.g. a$=12 or
a="text", or a procedure parameter has been given a value of the wrong
type.

<a id="D225"></a></p><p><b>225 SUBSCRIPT ERR</b>
<br>An out of range subscript has been specified for an array variable e.g. a(0)
or a(10) when the array a() has been declared as having 9 elements.

<a id="D226"></a></p><p><b>226 BAD FN ARGS</b>
<br>An illegal number or type of arguments has been supplied to a function,
e.g. LOG(-1).

<a id="D227"></a></p><p><b>227 MISMATCHED ()'s</b>
<br>Brackets have not been paired up correctly.

<a id="D228"></a></p><p><b>228 SYNTAX ERR</b>
<br>A syntax error has been detected during the translation of a procedure.

<a id="D229"></a></p><p><b>229 DEVICE LOAD ERR</b>
<br>A program or peripheral pack has been removed during its
verification by the Organiser or the pack has become corrupted.

<a id="D230"></a></p><p><b>230 DEVICE MISSING</b>
<br>An attempt has been made to access a device which is not present, e.g. a
printer. When no printer is connected, the LPRINT command will produce this
error.

<a id="D231"></a></p><p><b>231 BAD DEVICE CALL</b>
<br>Occurs if an illegal operation is requested of a device.

<a id="D232"></a></p><p><b>232 PAK NOT COPYABLE</b>
<br>An attempt has been made to copy a pack which is copy-protected.

<a id="D233"></a></p><p><b>233 DIRECTORY FULL</b>
<br>Only 110 data files are allowed on each device. An attempt has been made to
create a file which exceeds this limit.

<a id="D234"></a></p><p><b>234 FILE NOT FOUND</b>
<br>An attempt has been made to access a file which does not exist on the
specified device.

<a id="D235"></a></p><p><b>235 FILE EXISTS</b>
<br>An attempt has been made to create a file or procedure under a name which
already exists on that device.

<a id="D236"></a></p><p><b>236 BAD FILE NAME</b>
<br>A file name has been specified which does not conform to the rules. (Max 8
characters, alphanumeric starting with a letter.)

<a id="D237"></a></p><p><b>237 BAD RECORD TYPE</b>
<br>Occurs only when running machine language programs.

<a id="D238"></a></p><p><b>238 END OF FILE</b>
<br>Occurs when an attempt is made to read past the end of a data file.

<a id="D239"></a></p><p><b>239 PACK FULL</b>
<br>An attempt has been made to write to a full Datapak.

<a id="D240"></a></p><p><b>240 UNKNOWN PACK</b>
<br>A pack not supported by the Organiser II has been fitted to one of the
devices.

<a id="D241"></a></p><p><b>241 PACK NOT BLANK</b>
<br>Datapak needs formatting as data remnants are still present.

<a id="D242"></a></p><p><b>242 PACK CHANGED</b>
<br>Occurs when calling operating system machine language routines or when a
pack is changed in the middle of a COPY.

<a id="D243"></a></p><p><b>243 BAD DEVICE NAME</b>
<br>A device name other than A, B or C has been used.

<a id="D244"></a></p><p><b>244 READ ONLY PACK</b>
<br>An attempt has been made to write to a program pack. These may be read from,
but not written to.

<a id="D245"></a></p><p><b>245 WRITE PACK ERR</b>
<br>The Organiser cannot write data to one of the Datapaks. Try re-fitting it.

<a id="D246"></a></p><p><b>246 NO PACK</b>
<br>There is no Datapak fitted to the device named in an instruction such as
CREATE, OPEN etc. or a pack has been removed during pack access.

<a id="D247"></a></p><p><b>247 FN ARGUMENT ERR</b>
<br>The wrong type of argument has been passed to a function or a user's
procedure.

<a id="D248"></a></p><p><b>248 STACK UNDERFLOW</b>
<br>Will only occur when users machine language program destroys the Organiser's
stack.

<a id="D249"></a></p><p><b>249 STACK OVERFLOW</b>
<br>As above.

<a id="D250"></a></p><p><b>250 NUM TO STR ERR</b>
<br>Only occurs when calling operating system machine language routines.

<a id="D251"></a></p><p><b>251 DIVIDE BY ZERO</b>
<br>An attempt has been made to divide by zero.

<a id="D252"></a></p><p><b>252 STR TO NUM ERR</b>
<br>A non-numeric string has been passed to the VAL function.

<a id="D253"></a></p><p><b>253 EXPONENT RANGE</b>
<br>A number has exceeded the exponent limit of + or -99.

<a id="D254"></a></p><p><b>254 OUT OF MEMORY</b>
<br>Either the internal memory of the machine is fully occupied by programs,
diary entries and data files, or the current program has used up all
available memory.

<a id="D255"></a></p><p><b>255 NO ALLOC CELLS</b>
<br>Seen only when running machine language routines which access internal
buffer space.

</p><hr>

<h2>Index</h2>
<p>$ sign
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#C-3a">for hexadecimal numbers</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-4a">for string variables</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-14b">on procedure name</a>
<br>% sign
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-3c">for integer variables</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-14b">on procedure name</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-4a">used to access ASCII values</a>
<br>? character
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-1b">displaying</a>
<br>æ sign
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-1b">displaying</a>

</p><p><b>A</b>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-12a">aborting running procedures</a>
<br>ABS function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#ABS">syntax and summary</a>
<br>ACOS function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#ACOS">syntax and summary</a>
<br>ADDR function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#ADDR">syntax and summary</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#C-1">addresses in memory</a>
<br>AND, logical operator
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p4-5a">explained</a>
<br>APPEND command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-4c">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#APPEND">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D205">ARG COUNT ERR</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p4-1a">arithmetic operators</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-6a">array variables</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-6a">example integer array</a>
<br>ASC function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#ASC">syntax and summary</a>
<br>ASCII codes
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-4a">accessing with %</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#A-4a">ASCII values, accessing</a>
<br>ASIN function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#ASIN">syntax and summary</a>
<br>AT command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#AT">syntax and summary</a>
<br>ATAN function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#ATAN">syntax and summary</a>

</p><p><b>B</b>
<br>BACK command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-5a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#BACK">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D215">BAD ARRAY SIZE error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D208">BAD ASSIGNMENT error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D219">BAD CHARACTER error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D216">BAD DECLARATION error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D231">BAD DEVICE CALL error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D243">BAD DEVICE NAME error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D207">BAD FIELD LIST error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D236">BAD FILE NAME error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D226">BAD FN ARGS error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D222">BAD IDENTIFIER error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D209">BAD LOGICAL NAME error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D218">BAD NUMBER error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D197">BAD PROC NAME error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D237">BAD RECORD TYPE error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D194">BATTERY TOO LOW error</a>
<br>BEEP command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#BEEP">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-3c">branches</a>
<br>BREAK command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-3a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#BREAK">syntax and summary</a>

</p><p><b>C</b>
<br>calculator memories
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-5b">as OPL variables</a>
<br>characters
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-4a">accessing ASCII code</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-5">control</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-1b">printing non-key ones</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-6">user defined</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p8-8a">user-defined, example</a>
<br>CHR$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-1b">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#CHR_">syntax and summary</a>
<br>Clock
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#B-1">technical details</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-7">UDGs used by</a>
<br>CLOCK command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p8-15a">example of</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#CLOCK">syntax and summary</a>
<br>CLOSE command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-8b">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#CLOSE">Syntax and summary</a>
<br>CLS command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-3b">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#CLS">syntax and summary</a>
<br>CM
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-13b">translating procedures for</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a">COM, file extension</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-4c">commas, in OPL syntax</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-10a">concatenating strings</a>
<br>CONTINUE command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#CONTINUE">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#A-5">control characters</a>
<br>Copy
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-10b">Prog menu option</a>
<br>COPY command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#COPY">syntax and summary</a>
<br>copying
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-10b">procedures</a>
<br>COPYW command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a">file extensions for</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#COPYW">syntax and summary</a>
<br>COS function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#COS">syntax and summary</a>
<br>COUNT function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#COUNT">syntax and summary</a>
<br>CREATE command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-3a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#CREATE">syntax and summary</a>

</p><p><b>D</b>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-1a">data files</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-8a">changing current in OPL</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-8b">closing in OPL</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-3a">creating in OPL</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p8-11a">example program for handling</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-1a">handling in OPL</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-7a">opening in OPL</a>
<br>Datapaks
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#B-2">technical details</a>
<br>DATIM$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#DATIM_">syntax summary</a>
<br>DAY function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-4d">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#DAY">syntax and summary</a>
<br>DAYNAME$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#DAYNAME_">syntax and summary</a>
<br>DAYS function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#DAYS">syntax and summary</a>
<br>declaring variables
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-2a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-4b">LOCAL and GLOBAL</a>
<br>DEG function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#DEG">syntax and summary</a>
<br>Delete
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-11a">Prog menu</a>
<br>DELETE command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#DELETE">syntax and summary</a>
<br>DELETEW command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a">file extensions for</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#DELETEW">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D229">DEVICE LOAD ERR</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D230">DEVICE MISSING error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D193">DEVICE READ FAIL error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D192">DEVICE WRITE FAIL error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a">DIA, file extension</a>
<br>diary files
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p8-19a">example program for handling</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-2a">format of records in</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#B-1">dimensions of Organiser</a>
<br>Dir
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-10a">Prog menu option</a>
<br>DIR$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#DIR_">syntax and summary</a>
<br>directory
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-10a">of procedures</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D233">DIRECTORY FULL error</a>
<br>DIRW$
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a">file extensions for</a>
<br>DIRW$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#DIRW_">syntax and summary</a>
<br>DISP function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#DISP">syntax and summary</a>
<br>display
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#B-1">technical details </a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D251">DIVIDE BY ZERO error</a>
<br>DO/UNTIL command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#DO-UNTIL">syntax and summary</a>
<br>DO/UNTIL commands
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-1a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#DO-UNTIL">syntax and summary</a>
<br>DOW function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#DOW">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D214">DUPLICATE NAME error</a>

</p><p><b>E</b>
<br>Edit
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-9b">Prog menu option</a>
<br>EDIT command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#EDIT">syntax and summary</a>
<br>editing
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-9b">procedures</a>
<br>ELSE statement
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#ELSE">syntax and summary</a>
<br>End
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-5b">OPL editor menu option</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D238">END OF FILE error</a>
<br>EOF function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#EOF">syntax and summary</a>
<br>ERASE command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-6b">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#ERASE">syntax and summary</a>
<br>erasing
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-11a">procedures</a>
<br>ERR function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p7-8a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#ERR">syntax and summary</a>
<br>ERR$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#ERR_">syntax and summary</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p7-8a">error messages</a>
<br>errors
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p7-1a">common OPL errors</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p7-8b">generating for debugging</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p7-8a">messages</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p7-4a">run-time</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D206">ESCAPE error</a>
<br>ESCAPE ON/OFF command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-4b">risks of</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#ESCAPE">syntax and summary</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-12a">escaping from procedures</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-4b">escaping from procedures</a>
<br>EXIST function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#EXIST">syntax and summary</a>
<br>EXP function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#EXP">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D253">EXPONENT RANGE error</a>

</p><p><b>F</b>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D201">FIELD MISMATCH error</a>
<br>fields
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-3d">field names</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-3d">field qualifiers</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-2a">handling in OPL</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-4b">input to</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D235">FILE EXISTS error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a">file extensions</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D199">FILE IN USE error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D234">FILE NOT FOUND error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D196">FILE NOT OPEN error</a>
<br>files, any type
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a">handling in OPL</a>
<br>Find
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-5b">OPL editor menu option</a>
<br>FIND function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-6a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#FIND">syntax and summary</a>
<br>FINDW function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p8-19a">example of</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#FINDW">syntax and summary</a>
<br>FIRST command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-5a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#FIRST">syntax and summary</a>
<br>FIX$ functions
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#FIX_">syntax and summary</a>
<br>floating point variables
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-3a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p4-2b">precedence in OPL</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-3a">range</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-9a">rounded down</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-7b">type conversion</a>
<br>FLT function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#FLT">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D247">FN ARGUMENT ERR</a>
<br>FREE function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#FREE">syntax and summary</a>

</p><p><b>G</b>
<br>GEN$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#GEN_">syntax and summary</a>
<br>GET function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-4a">accessing ASCII codes</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-4g">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-4b">numbers returned by</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#GET">syntax and summary</a>
<br>GET$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#GET_">syntax and summary</a>
<br>GLOBAL command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#GLOBAL">syntax and summary</a>
<br>GOTO command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-3b">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#GOTO">syntax and summary</a>
<br>HEX$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#HEX_">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#C-3a">hexadecimal numbers</a>
<br>Home
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-5b">OPL editor menu option</a>
<br>HOUR function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#HOUR">syntax and summary</a>

</p><p><b>I</b>
<br>IABS function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#IABS">syntax and summary</a>
<br>IF/ELSEIF/ELSE/ENDIF command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-3c">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#IF">syntax and summary</a>
<br>INPUT command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-11b">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p8-7a">in example input routine</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#INPUT">syntax and summary</a>
<br>INT function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#INT">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D195">INTEGER OVERFLOW error</a>
<br>integer variables
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-3b">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-3b">range</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-7b">type conversion</a>
<br>INTF function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#INTF">syntax and summary</a>

</p><p><b>J</b>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-3b">jumps in procedures</a>

</p><p><b>K</b>
<br>KEY function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-4b">numbers returned by</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#KEY">syntax and summary</a>
<br>KEY$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#KEY_">syntax and summary</a>
<br>KSTAT command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#KSTAT">syntax and summary</a>

</p><p><b>L</b>
<br>labels
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p7-5a">with ONERR command</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-3b">labels with GOTO command</a>
<br>LAST command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-5a">explained</a>
<br>LEFT$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-10b">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#LEFT_">syntax and summary</a>
<br>LEN function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#LEN">syntax and summary</a>
<br>LN function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#LN">syntax and summary</a>
<br>LOC function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#LOC">syntax and summary</a>
<br>LOCAL command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-4b">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#LOCAL">syntax and summary</a>
<br>LOG function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#LOG">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p4-3b">logical expressions in OPL</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-3c">logical file names</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p4-5a">logical operators</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p4-5b">with floating point values</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p4-5c">with integer values</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-1a">loops</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-4b">breaking out of</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-4b">endless, how to avoid</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-1b">maximum nested</a>
<br>LOWER$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#LOWER_">syntax and summary</a>
<br>LPRINT command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#LPRINT">syntax and summary</a>

</p><p><b>M</b>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#C-3b">machine language</a>
<br>main menu
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-11b">running procedures from</a>
<br>MAX function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#MAX">syntax and summary</a>
<br>MEAN function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#MEAN">syntax and summary</a>
<br>memories, calculator
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-5b">as OPL variables</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#C-1">memory maps</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D202">MENU TOO BIG error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p7-8a">messages, error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#B-1">microprocessor, technical details</a>
<br>MID$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-10b">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#MID_">syntax and summary</a>
<br>MIN function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#MIN">syntax and summary</a>
<br>MINUTE function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#MINUTE">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D221">MISMATCHED " error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D227">MISMATCHED ()'s</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D210">MISSING COMMA error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D204">MISSING EXTERNAL error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D211">MISSING LABEL error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D203">MISSING PROC error</a>
<br>MONTH function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#MONTH">syntax and summary</a>
<br>MONTH$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#MONTH_">syntax and summary</a>

</p><p><b>N</b>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D223">NAME TOO LONG error</a>
<br>names
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-1b">of procedures</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-2b">of variables</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-3a">New option</a>
<br>NEXT command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-5a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#NEXT">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D255">NO ALLOC CELLS error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D246">NO PACK error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D217">NO PROC NAME error</a>
<br>NOT, logical operator
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p4-5a">explained</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a">NTS, file extension</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D250">NUM TO STR ERR</a>
<br>NUM$ function

</p><p><b>O</b>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a">ODB, file extension</a>
<br>OFF command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#OFF">syntax and summary</a>
<br>ONERR command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p7-5a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#ONERR">syntax and summary</a>
<br>OPEN command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-7a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#OPEN">syntax and summary</a>
<br>operators
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p4-1a">available in OPL</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p4-1b">precedence in OPL</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a">OPL, file extension</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a">OPO, file extension</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a">OPT, file extension</a>
<br>OR, logical operator
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p4-5a">explained</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D254">OUT OF MEMORY error</a>

</p><p><b>P</b>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D242">PACK CHANGED error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D239">PACK FULL error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D241">PACK NOT BLANK error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a">PAG, file extensions</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D232">PAK NOT COPYABLE error</a>
<br>parameters
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-12a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-13a">multiple</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-14a">returning</a>
<br>PAUSE command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#PAUSE">syntax and summary</a>
<br>PEEKB function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#PEEKB">syntax and summary</a>
<br>PEEKW function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#PEEKW">tax and summary</a>
<br>PI function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#PI">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p6-1a">PLN, file extension</a>
<br>POKEB command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#POKEB">syntax and summary</a>
<br>POKEW command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#POKEW">syntax and summary</a>
<br>POS function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#POS">syntax and summary</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-5a">explained</a>
<br>POSITION command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-5a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#POSITION">syntax and summary</a>
<br>pound sign
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-1b">displaying</a>
<br>PRINT command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-4a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#PRINT">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-9c">Printing procedures</a>
<br>procedure names
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-1b">length and format</a>
<br>procedures,
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-10b">copying</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-2b">creating</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-5a">editing new</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-9b">editing old</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-11a">erasing</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-12a">escaping from</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-4b">escaping from</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p8-1a">examples</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-1a">Introduction to</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-9c">listing/printing</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-3a">names</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-1b">names format</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-12a">quitting out of</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-4b">quitting out of</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-13a">renaming</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-11b">running from main menu</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-7b">saving</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-6a">translating</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-13b">translating for XP/CM</a>
<br>Prog menu
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-2a">summary of</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-3b">program labels</a>
<br>programs
<br>&nbsp;&nbsp;See procedures
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p8-1a">programs, examples</a>

</p><p><b>Q</b>
<br>question mark
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-1b">displaying</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-6b">Quit, Prog option</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-12a">quitting running procedures</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-4b">quitting running procedures</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-10c">quotation marks in strings</a>

</p><p><b>R</b>
<br>RAD function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#RAD">syntax and summary</a>
<br>RAISE command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p7-8b">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#RAISE">syntax and summary</a>
<br>RANDOMIZE command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#RANDOMIZE">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D244">READ ONLY PACK error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D200">READ PACK ERROR</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D198">RECORD TOO BIG error</a>
<br>records
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-4a">adding to file in OPL</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-5a">changing current in OPL</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-6b">erasing in OPL</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-6a">finding in OPL</a>
<br>RECSIZE function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#RECSIZE">syntax and summary</a>
<br>REM command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#REM">syntax and summary</a>
<br>RENAME command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#RENAME">syntax and summary</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-13a">renaming procedures</a>
<br>REPT$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#REPT_">syntax and summary</a>
<br>RETURN command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#RETURN">syntax and summary</a>
<br>RETURN command (OPL)
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-14a">explained</a>
<br>RIGHT$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-10b">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#RIGHT_">syntax and summary</a>
<br>RND function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#RND">syntax and summary</a>
<br>Run
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-8b">Prog menu option</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-8b">running procedures</a>

</p><p><b>S</b>
<br>Save
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-7b">Prog menu</a>
<br>saving
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-7b">procedures</a>
<br>SCI$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#SCI_">syntax and summary</a>
<br>SECOND function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#SECOND">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-4e">semi-colons, in OPL syntax</a>
<br>SIN function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#SIN">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-10b">Slicing strings</a>
<br>SPACE function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#SPACE">syntax and summary</a>
<br>SQR function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#SQR">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D249">STACK OVERFLOW error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D248">STACK UNDERFLOW error</a>
<br>STD function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#STD">syntax and summary</a>
<br>STOP command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#STOP">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D252">STR TO NUM error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D220">STRING TOO LONG error</a>
<br>string variables
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-3d">explained</a>
<br>strings
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-10a">concatenating</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-4b">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-4a">maximum length</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-10c">quotation marks in</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-10b">slicing</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D213">STRUCTURE ERR</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D225">SUBSCRIPT error</a>
<br>SUM function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#SUM">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D228">SYNTAX ERR</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#C-1">system variables</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-7a">operations upon</a>

</p><p><b>T</b>
<br>TAN function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#TAN">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D212">TOO COMPLEX error</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-7a">Tran, Prog option</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-7a">translating procedures</a>
<br>TRAP command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p7-7a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#TRAP">syntax and summary</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p7-4b">trapping errors in OPL</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-7b">type conversion, automatic</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-9b">type conversion, string/numeric</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D224">TYPE MISMATCH error</a>

</p><p><b>U</b>
<br>UDG command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-6">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#UDG">syntax and summary</a>
<br>UDGs
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p8-8a">example program using</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p8-15a">example program using</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-6">explained</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D240">UNKNOWN PACK error</a>
<br>UNTIL command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#UNTIL">syntax and summary</a>
<br>UPDATE command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#UPDATE">syntax and summary</a>
<br>UPPER$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#UPPER_">syntax and summary</a>
<br>USE command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p5-8a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#USE">syntax and summary</a>
<br>user defined characters
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#A-6">explained</a>
<br>user defined graphics
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p8-8a">example program using</a>
<br>USR function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#USR">syntax and summary</a>
<br>USR$ function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#USR_">syntax and summary</a>

</p><p><b>V</b>
<br>VAL function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#VAL">syntax and summary</a>
<br>VAR function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#VAR">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-2a">variables</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-6a">array</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-2a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-3a">floating point</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-4b">GLOBAL v LOCAL</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-7b">int./floating pt. conversion</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-3b">integer</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-2b">names</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-7a">operations upon</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p2-3d">string</a>
<br>VIEW function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#VIEW">syntax and summary</a>

</p><p><b>W</b>
<br>WEEK function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#WEEK">syntax and summary</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#B-1">weight of Organiser</a>
<br>WHILE/ENDWH command
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p3-1a">explained</a>
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#WHILE-ENDWH">syntax and summary</a>
<br><a href="https://www.jaapsch.net/psion/manlzpg.htm#D245">WRITE PACK ERR</a>

</p><p><b>X</b>
<br>XP
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-13b">translating procedures for</a>
<br>Xtran
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-13b">OPL editor option</a>

</p><p><b>Y</b>
<br>YEAR function
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#YEAR">syntax and summary</a>

</p><p><b>Z</b>
<br>Zap
<br>&nbsp;&nbsp;<a href="https://www.jaapsch.net/psion/manlzpg.htm#p1-5b">OPL editor menu option</a>

</p><hr>

<div class="nav"><ul>
<li><a href="https://www.jaapsch.net/index.htm">Home</a></li>
</ul></div>



</body></html>