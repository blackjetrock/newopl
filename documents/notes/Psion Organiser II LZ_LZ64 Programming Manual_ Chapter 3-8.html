<!DOCTYPE html PUBLIC "-//IETF//DTD HTML//EN">
<!-- saved from url=(0085)https://web.archive.org/web/20071228050654/http://members.surfeu.at/org2/manlzpg2.htm -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252"><!-- is_embed=False -->
<script>
  const observer = new PerformanceObserver((list) => {
    list.getEntries().forEach((entry) => {
      console.log('%o', entry);
    })
  });
  observer.observe({type: "navigation", buffered: true});
</script>
<script src="./Psion Organiser II LZ_LZ64 Programming Manual_ Chapter 3-8_files/athena.js" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app201.us.archive.org';v.server_ms=249;archive_analytics.send_pageview({});});</script>
<script type="text/javascript" src="./Psion Organiser II LZ_LZ64 Programming Manual_ Chapter 3-8_files/bundle-playback.js" charset="utf-8"></script>
<script type="text/javascript" src="./Psion Organiser II LZ_LZ64 Programming Manual_ Chapter 3-8_files/wombat.js" charset="utf-8"></script>
<script>window.RufflePlayer=window.RufflePlayer||{};window.RufflePlayer.config={"autoplay":"on","unmuteOverlay":"hidden"};</script>
<script type="text/javascript" src="./Psion Organiser II LZ_LZ64 Programming Manual_ Chapter 3-8_files/ruffle.js"></script>
<script type="text/javascript">
    __wm.init("https://web.archive.org/web");
  __wm.wombat("http://members.surfeu.at:80/org2/manlzpg2.htm","20071228050654","https://web.archive.org/","web","/_static/",
	      "1198818414");
</script>
<link rel="stylesheet" type="text/css" href="./Psion Organiser II LZ_LZ64 Programming Manual_ Chapter 3-8_files/banner-styles.css">
<link rel="stylesheet" type="text/css" href="./Psion Organiser II LZ_LZ64 Programming Manual_ Chapter 3-8_files/iconochive.css">
<!-- End Wayback Rewrite JS Include -->


<title>Psion Organiser II LZ/LZ64 Programming Manual: Chapter 3-8</title>
</head>

<body bgcolor="#FFFFFF"><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script>__wm.rw(0);</script>
<div id="wm-ipp-base" lang="en" style="display: block; direction: ltr;"><template shadowrootmode="closed"><div id="wm-ipp" style="position:fixed;left:0;top:0;right:0;">
<div id="donato" style="position:relative;width:100%;">
  <div id="donato-base">
    <iframe id="donato-if" src="https://archive.org/includes/donate.php?as_page=1&amp;platform=wb&amp;referer=https%3A//web.archive.org/web/20071228050654/http%3A//members.surfeu.at/org2/manlzpg2.htm" scrolling="no" frameborder="0" style="width:100%; height:100%">
    </iframe>
  </div>
</div><div id="wm-ipp-inside">
  <div id="wm-toolbar" style="position:relative;display:flex;flex-flow:row nowrap;justify-content:space-between;">
    <div id="wm-logo" style="/*width:110px;*/padding-top:12px;">
      <a href="https://web.archive.org/web/" title="Wayback Machine home page"><img src="https://web.archive.org/_static/images/toolbar/wayback-toolbar-logo-200.png" srcset="/_static/images/toolbar/wayback-toolbar-logo-100.png, /_static/images/toolbar/wayback-toolbar-logo-150.png 1.5x, /_static/images/toolbar/wayback-toolbar-logo-200.png 2x" alt="Wayback Machine" style="width:100px" border="0"></a>
    </div>
    <div class="c" style="display:flex;flex-flow:column nowrap;justify-content:space-between;flex:1;">
      <form class="u" style="display:flex;flex-direction:row;flex-wrap:nowrap;" target="_top" method="get" action="https://web.archive.org/web/submit" name="wmtb" id="wmtb"><input type="text" name="url" id="wmtbURL" value="http://members.surfeu.at/org2/manlzpg2.htm" onfocus="this.focus();this.select();" style="flex:1;" autocomplete="off"><input type="hidden" name="type" value="replay"><input type="hidden" name="date" value="20071228050654"><input type="submit" value="Go">
      </form>
      <div style="display:flex;flex-flow:row nowrap;align-items:flex-end;">
                <div class="s" id="wm-nav-captures" style="flex:1;"><a class="t" href="https://web.archive.org/web/*/http://members.surfeu.at/org2/manlzpg2.htm" title="See a list of every capture for this URL">22 captures</a><div class="r" title="Timespan for captures of this URL">15 Aug 2002 - 23 Feb 2008</div></div>
        <div class="k">
          <a href="https://web.archive.org/web/20071228050654/http://members.surfeu.at/org2/manlzpg2.htm" id="wm-graph-anchor">
            <div id="wm-ipp-sparkline" title="Explore captures for this URL" style="position: relative">
              <canvas id="wm-sparkline-canvas" width="725" height="27" border="0"></canvas>
            <div class="yt" style="display: none; width: 25px; height: 27px;"></div><div class="mt" style="display: none; width: 2px; height: 27px;"></div></div>
          </a>
        </div>
      </div>
    </div>
    <div class="n">
      <table>
        <tbody>
          <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
          <tr class="m">
            <td class="b" nowrap="nowrap"><a href="https://web.archive.org/web/20071127141213/http://members.surfeu.at:80/org2/manlzpg2.htm" title="27 Nov 2007"><strong>Nov</strong></a></td>
            <td class="c" id="displayMonthEl" title="You are here: 05:06:54 Dec 28, 2007">DEC</td>
            <td class="f" nowrap="nowrap"><a href="https://web.archive.org/web/20080223000315/http://members.surfeu.at:80/org2/manlzpg2.htm" title="23 Feb 2008"><strong>Feb</strong></a></td>
          </tr>
          <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
          <tr class="d">
            <td class="b" nowrap="nowrap"><a href="https://web.archive.org/web/20071127141213/http://members.surfeu.at:80/org2/manlzpg2.htm" title="14:12:13 Nov 27, 2007"><img src="https://web.archive.org/_static/images/toolbar/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0"></a></td>
            <td class="c" id="displayDayEl" style="width:34px;font-size:22px;white-space:nowrap;" title="You are here: 05:06:54 Dec 28, 2007">28</td>
            <td class="f" nowrap="nowrap"><a href="https://web.archive.org/web/20080223000315/http://members.surfeu.at:80/org2/manlzpg2.htm" title="00:03:15 Feb 23, 2008"><img src="https://web.archive.org/_static/images/toolbar/wm_tb_nxt_on.png" alt="Next capture" width="14" height="16" border="0"></a></td>
          </tr>
          <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
          <tr class="y">
            <td class="b" nowrap="nowrap"><a href="https://web.archive.org/web/20051027083844/http://members.surfeu.at:80/org2/manlzpg2.htm" title="27 Oct 2005"><strong>2005</strong></a></td>
            <td class="c" id="displayYearEl" title="You are here: 05:06:54 Dec 28, 2007">2007</td>
            <td class="f" nowrap="nowrap">2008</td>
          </tr>
        </tbody>
      </table>
    </div>
    <div class="r" style="display:flex;flex-flow:column nowrap;align-items:flex-end;justify-content:space-between;">
      <div id="wm-btns" style="text-align:right;height:23px;">
                <span class="xxs">
          <div id="wm-save-snapshot-success">success</div>
          <div id="wm-save-snapshot-fail">fail</div>
          <a id="wm-save-snapshot-open" href="https://web.archive.org/web/20071228050654/http://members.surfeu.at/org2/manlzpg2.htm#" title="Share via My Web Archive" style="display: inline-block;">
            <span class="iconochive-web"></span>
          </a>
          <a href="https://archive.org/account/login.php" title="Sign In" id="wm-sign-in" style="display: none;">
            <span class="iconochive-person"></span>
          </a>
          <span id="wm-save-snapshot-in-progress" class="iconochive-web"></span>
        </span>
                <a class="xxs" href="http://faq.web.archive.org/" title="Get some help using the Wayback Machine" style="top:-6px;"><span class="iconochive-question" style="color:rgb(87,186,244);font-size:160%;"></span></a>
        <a id="wm-tb-close" href="https://web.archive.org/web/20071228050654/http://members.surfeu.at/org2/manlzpg2.htm#close" style="top:-2px;" title="Close the toolbar"><span class="iconochive-remove-circle" style="color:#888888;font-size:240%;"></span></a>
      </div>
      <div id="wm-share" class="xxs">
        <a href="https://web.archive.org/web/20071228050654/http://web.archive.org/screenshot/http://members.surfeu.at/org2/manlzpg2.htm" id="wm-screenshot" title="screenshot" style="visibility: hidden;">
          <span class="wm-icon-screen-shot"></span>
        </a>
        <a href="https://web.archive.org/web/20071228050654/http://members.surfeu.at/org2/manlzpg2.htm#" id="wm-video" title="video">
          <span class="iconochive-movies"></span>
        </a>
        <a id="wm-share-facebook" href="https://web.archive.org/web/20071228050654/http://members.surfeu.at/org2/manlzpg2.htm#" data-url="https://web.archive.org/web/20071228050654/http://members.surfeu.at:80/org2/manlzpg2.htm" title="Share on Facebook" style="margin-right:5px;" target="_blank"><span class="iconochive-facebook" style="color:#3b5998;font-size:160%;"></span></a>
        <a id="wm-share-twitter" href="https://web.archive.org/web/20071228050654/http://members.surfeu.at/org2/manlzpg2.htm#" data-url="https://web.archive.org/web/20071228050654/http://members.surfeu.at:80/org2/manlzpg2.htm" title="Share on Twitter" style="margin-right:5px;" target="_blank"><span class="iconochive-twitter" style="color:#1dcaff;font-size:160%;"></span></a>
      </div>
      <div style="padding-right:2px;text-align:right;white-space:nowrap;">
        <a id="wm-expand" class="wm-btn wm-closed" href="https://web.archive.org/web/20071228050654/http://members.surfeu.at/org2/manlzpg2.htm#expand"><span id="wm-expand-icon" class="iconochive-down-solid"></span> <span class="xxs" style="font-size:80%;">About this capture</span></a>
      </div>
    </div>
  </div>
    <div id="wm-capinfo" style="border-top:1px solid #777;display:none; overflow: hidden">
        <div id="wm-capinfo-notice" source="api"></div>
                <div id="wm-capinfo-collected-by">
    <div style="background-color:#666;color:#fff;font-weight:bold;text-align:center">COLLECTED BY</div>
    <div style="padding:3px;position:relative" id="wm-collected-by-content">
      <div style="display:inline-block;vertical-align:top;width:49%;">
			<span class="c-logo" style="background-image:url(https://archive.org/services/img/web)"></span>
		<div>Collection: <a style="color:#33f;" href="https://archive.org/details/web" target="_new"><span class="wm-title">web</span></a></div>
	      </div>
    </div>
    </div>
    <div id="wm-capinfo-timestamps">
    <div style="background-color:#666;color:#fff;font-weight:bold;text-align:center" title="Timestamps for the elements of this page">TIMESTAMPS</div>
    <div>
      <div id="wm-capresources" style="margin:0 5px 5px 5px;max-height:250px;overflow-y:scroll !important"></div>
      <div id="wm-capresources-loading" style="text-align:left;margin:0 20px 5px 5px;display:none"><img src="https://web.archive.org/_static/images/loading.gif" alt="loading"></div>
    </div>
    </div>
  </div></div></div><link rel="stylesheet" type="text/css" href="./Psion Organiser II LZ_LZ64 Programming Manual_ Chapter 3-8_files/banner-styles.css"><link rel="stylesheet" type="text/css" href="./Psion Organiser II LZ_LZ64 Programming Manual_ Chapter 3-8_files/iconochive.css"><div class="wb-autocomplete-suggestions "></div></template>
</div><div id="wm-ipp-print">The Wayback Machine - https://web.archive.org/web/20071228050654/http://members.surfeu.at:80/org2/manlzpg2.htm</div>
<script type="text/javascript">//<![CDATA[
__wm.bt(725,27,25,2,"web","http://members.surfeu.at/org2/manlzpg2.htm","20071228050654",1996,"/_static/",["/_static/css/banner-styles.css?v=S1zqJCYt","/_static/css/iconochive.css?v=3PDvdIFv"], false);
  __wm.rw(1);
//]]></script>
<!-- END WAYBACK TOOLBAR INSERT -->
 

<table border="0" cellpadding="0" cellspacing="0" width="100%">
  <tbody><tr>
    <td align="center" bgcolor="#FFFF00"><img src="./Psion Organiser II LZ_LZ64 Programming Manual_ Chapter 3-8_files/psion_logo.gif" alt="Psion Homepage Logo." width="602" height="134"></td>
  </tr>
</tbody></table>

<font face="Arial" size="2">

<p align="center"><font size="6"><em><strong>LZ/LZ64 Programming Manual Chapter 3-8</strong></em></font></p>

<p align="center"><img src="./Psion Organiser II LZ_LZ64 Programming Manual_ Chapter 3-8_files/psibar.gif" width="312" height="24" alt="Psion bar."></p>

<a name="3-1a"></a><p align="left"><font size="5"><b>3 Loops and branches</b></font>

</p><p>So far we have only considered programs which run in a straight line
from start to finish. They consist of a number of instructions which
are executed in the order they appear in the program; if you want to
carry out an instruction more than once you must repeat it.

</p><p>That is clearly very inefficient. A far more efficient method is for
the program to be able to loop around a particular part as many
times as you require, or until a certain condition is met.

</p><p>There are a number of ways of doing this in OPL.

</p><p>The first two are the <b>DO/UNTIL</b> and the <b>WHILE/ENDWH</b> loops. These
are known as structures. They operate in a similar way to each other, with one
difference.
</p><ul><li>The DO/UNTIL structure tests for a condition being fulfilled at
      the end of the loop.</li>
    <li>The WHILE/ENDWH structure tests the condition at the start of the loop.</li></ul>

<a name="3-1b"></a><p>You can have up to eight loops nested within each other.


<a name="3-2a"></a></p><p><font size="3"><b>The DO/UNTIL loop</b></font>

</p><p>Here is an example of a DO/UNTIL loop:

<font face="Courier">
</font></p><p><font face="Courier">a%=10
<br>DO
<br> PRINT "A=";a%
<br> a%=a%-1
<br>UNTIL a%=0
</font>

</p><p>First 10 is assigned to a%. The loop starts on the next line, with the
instruction DO. This says to OPL:

</p><p>"Execute all the following instructions until an UNTIL is reached. If
the condition following UNTIL is not met, repeat the same set of
instructions until it is."

</p><p>The next line displays "A=", followed by the value of a%. The
first time through the loop, this is 10.

</p><p>Next, the value of a% has 1 subtracted from it so that a% is 9. Now
comes UNTIL, followed by a condition. The condition is that a% is
equal to zero. It isn't yet, so the program returns to DO and the loop
is repeated. Now a% decrements to 8, and again the condition fails.
This process continues until a% does equal zero.

</p><p>When a% equals zero the loop finishes and the program continues with the
instructions after UNTIL.


<a name="3-2b"></a></p><p><font size="3"><b>The WHILE/ENDWH loop</b></font>

</p><p>The WHILE/ENDWH loop is similar, except that the test condition is at
the beginning. For example:

<font face="Courier">
</font></p><p><font face="Courier">a=4.1
<br>b=2.7
<br>WHILE a&gt;b
<br> PRINT "a is greater than b"
<br> b=b+1.04
<br>ENDWH
</font>

<a name="3-3a"></a></p><p><font size="3"><b>BREAK</b></font>

</p><p>BREAK can be used in conjunction with an IF statement, see below, to break
out of a DO or WHILE loop. It jumps to the instruction after the end of the
loop.


<a name="3-3b"></a></p><p><font size="3"><b>Labels and jumps</b></font>

</p><p>Another command which can direct the program out of a straight sequence is
<b>GOTO</b>. This jumps to a <b>label</b>.

</p><p>In this example, when the program reaches the GOTO, it jumps to the
line beginning with the label exit::.

<font face="Courier">
</font></p><p><font face="Courier">GOTO exit::
<br>PRINT "MISS THIS LINE"
<br>PRINT "AND THIS ONE"
<br>exit::
</font>

</p><p>Labels end in a double colon.

</p><p>The label must be in the same procedure as the GOTO, and the jump
is not conditional, it always happens.


<a name="3-3c"></a></p><p><font size="3"><b>Branches</b></font>

</p><p>GOTO is a way of <b>branching</b>, but it is a fairly crude tool and can
make procedures difficult to read.

</p><p>Better is the <b>IF/ELSEIF/ELSE/ENDIF</b> structure. This structure is used to
perform one or more instructions IF a condition is met. If the condition
is not met, you can use an ELSEIF instruction, to test for another
condition. You can have any number of ELSEIF instructions within an
IF/ENDIF structure.

</p><p>After all likely things are catered for by the ELSEIF instructions, other
possibilities can be catered for by an ELSE statement, followed at the end
by the ENDIF statement. Here is an example:

<font face="Courier">
</font></p><p><font face="Courier">whatkey:
<br>LOCAL g%
<br>g%=GET
<br>PRINT "THAT KEY IS"
<br>IF g%&gt;64 AND g%&lt;91
<br> PRINT "UPPER CASE"
<br>ELSEIF g%&gt;96 AND g%&lt;123
<br> PRINT "lower case"
<br>ELSE
<br> PRINT "NOT A LETTER."
<br>ENDIF
<br>GET
</font>

</p><p>This just waits for a key to be pressed, and then prints that it is either
a lower or upper case letter. (If you don't realise the significance of the
numbers 64 and 91, see Appendix A.) If it is not a letter at all, then that
is printed, as allowed for by the ELSE statement.

</p><p>ELSEIF and ELSE statements are optional, but for every IF there must be a
corresponding ENDIF.


<a name="3-4b"></a></p><p><font size="3"><b>Endless Loops</b></font>

</p><p><b>ESCAPE OFF, GET, KEY and INPUT must be used with caution in loops</b>
for the following reasons:

</p><p>To halt the execution of a procedure, you normally press <b>ON/CLEAR</b>
then <b>Q</b>:
</p><ul>
    <li>If you've used an ESCAPE OFF command, you can't do this, as this
      disables <b>ON/CLEAR</b>. So you can only escape by removing the battery and
      thus losing data.</li>
    <li>If you've used a function such as GET or KEY to read a keypress, you
      have to press <b>ON/CLEAR</b> quickly followed by <b>Q</b> and repeat this very
      quickly a few times. This may be very difficult to do.</li></ul>


<p align="center"><img src="./Psion Organiser II LZ_LZ64 Programming Manual_ Chapter 3-8_files/orgbar.gif" width="312" height="24" alt="Organiser bar."></p>

<a name="4-1a"></a><p><font size="5"><b>4 Operators</b></font>

</p><p><b>Arithmetic operators</b>
<table>
<tbody><tr><td><font size="2" face="Arial"><b>+</b></font></td>
    <td><font size="2" face="Arial">add</font></td></tr>
<tr><td><font size="2" face="Arial"><b>-</b></font></td>
    <td><font size="2" face="Arial">subtract</font></td></tr>
<tr><td><font size="2" face="Arial"><b>*</b></font></td>
    <td><font size="2" face="Arial">multiply</font></td></tr>
<tr><td><font size="2" face="Arial"><b>/</b></font></td>
    <td><font size="2" face="Arial">divide</font></td></tr>
<tr><td><font size="2" face="Arial"><b>**</b></font></td>
    <td><font size="2" face="Arial">raise to a power</font></td></tr>
<tr><td><font size="2" face="Arial"><b>-</b></font></td>
    <td><font size="2" face="Arial">unary minus (make negative)</font></td></tr>
<tr><td><font size="2" face="Arial"><b>%</b></font></td>
    <td><font size="2" face="Arial">percent</font></td></tr>
</tbody></table>


</p><p><b>Comparison operators</b>
<table>
<tbody><tr><td><font size="2" face="Arial"><b>&gt;</b></font></td>
    <td><font size="2" face="Arial">greater than</font></td></tr>
<tr><td><font size="2" face="Arial"><b>&gt;=</b></font></td>
    <td><font size="2" face="Arial">greater than or equal to</font></td></tr>
<tr><td><font size="2" face="Arial"><b>&lt;</b></font></td>
    <td><font size="2" face="Arial">less than</font></td></tr>
<tr><td><font size="2" face="Arial"><b>&lt;=</b></font></td>
    <td><font size="2" face="Arial">less than or equal to</font></td></tr>
<tr><td><font size="2" face="Arial"><b>=</b></font></td>
    <td><font size="2" face="Arial">equal to</font></td></tr>
<tr><td><font size="2" face="Arial"><b>&lt;&gt;</b></font></td>
    <td><font size="2" face="Arial">not equal to</font></td></tr>
</tbody></table>

</p><p><b>Logical operators</b>
</p><p>AND
<br>OR
<br>NOT


<a name="4-1b"></a></p><p><font size="3"><b>Operator precedence</b></font>
<table>
<tbody><tr><td><font size="2" face="Arial">Highest:</font></td>
    <td><font size="2" face="Arial">**</font></td></tr>
<tr><td></td>
    <td><font size="2" face="Arial">- (Unary minus) NOT</font></td></tr>
<tr><td></td>
    <td><font size="2" face="Arial">* /</font></td></tr>
<tr><td></td>
    <td><font size="2" face="Arial">+ -</font></td></tr>
<tr><td></td>
    <td><font size="2" face="Arial">= &gt; &lt; &lt;&gt; &gt;= &lt;=</font></td></tr>
<tr><td><font size="2" face="Arial">Lowest:</font></td>
    <td><font size="2" face="Arial">AND OR</font></td></tr>
</tbody></table>

</p><p>The percent operator % is rather different as its effect depends
on the operator it is combined with. The way % works is described
in the calculator chapter of the operating manual.


</p><p><font size="3"><b>Using Brackets</b></font>

</p><p>An expression such as a+b+c presents no problems, as the result is
the same whichever addition is done first. However, you may want
to enforce precedence with brackets. For example:
<br>a+b*c/d

</p><p>is evaluated in the order: b multiplied by c, then divided by d, then
added to a. To perform the addition and the division before the
multiplication, use brackets:
<br>(a+b)*(c/d)
</p><ul><li>In an expression where all operators have equal precedence, they are
      evaluated from left to right</li>
    <li>Powers, however, are evaluated right to left. So for example, in the
      expression:</li>
      <br>a%**b%**c%
</ul>

<p>b% will first be raised to the power of c% and the resulting value will
be used as the power of a%.

</p><p>When in doubt, simply use brackets.


<a name="4-2b"></a></p><p><font size="3"><b>Precedence of integer and floating point values</b></font>

</p><p>You are free to mix floating point and integer values, in expressions, but
be aware how OPL handles the mix:
</p><ul><li>Floating point variables take priority over integers. So, in an
      expression linked by an operator to a floating point number, integers
      will be converted to floating point.</li>
<b>but then</b>
    <li>The result of the right hand side of an expression is converted to
      whatever type the left hand side is.</li></ul>

<p>For example, your procedure might include the expression:
<br>a%=b%+c

</p><p>This is handled like this: b% is converted to floating point and added to c.
The resulting floating point value is then automatically converted to an
integer in order to be assigned to the integer variable a%.

</p><p>These conversions may produce odd results, so be careful. For
example, a%=3.0*(7/2) assigns 9 to a%, but a%=(3.0*7)/2 assigns 10 to a%.


<a name="4-3b"></a></p><p><font size="3"><b>Logical expressions</b></font>

</p><p>The comparison operators and logical operators are based on the idea that
a certain situation can be evaluated as either true or false. For example,
if a%=6 and b%=8, a%&gt;b% would be false. They are useful for setting up
alternative paths in your procedures. For example you could say:

<font face="Courier">
</font></p><p><font face="Courier">IF salary&lt;expenses
<br> PRINT "bad"
<br>ELSEIF salary&gt;expenses
<br> PRINT "good"
<br>ENDIF
</font>

</p><p>You can also make use of the fact that the result of these logical
expressions is represented by an integer:
</p><ul><li>True is represented by the integer -1</li>
    <li>False is represented by the integer 0 (zero)</li></ul>

<p>These integers can be returned to a variable or printed out to the
screen to tell you whether a particular condition is true or false, or
used in an IF statement.

</p><p>For example, in a procedure you might arrive at two sub-totals, a and
b. You want to find out which is the greater. So include the
statement, PRINT a&gt;b. If zero is displayed, a and b are equal or b is
the larger number but if - 1 is displayed, 'a&gt;b' is true - a is the larger.

<table>
<tbody><tr><td></td><td>Example</td><td>Result</td><td>Integer Returned</td></tr>
<tr><td rowspan="2">&lt;</td>
    <td rowspan="2">a&lt;b</td>
    <td>True if a less than b</td>
    <td>-1</td></tr>
<tr><td>False if a greater than or equal to b</td>
    <td>0</td></tr>
<tr><td rowspan="2">&gt;</td>
    <td rowspan="2">a&gt;b</td>
    <td>True if a greater than b</td>
    <td>-1</td></tr>
<tr><td>False if a less than or equal to b</td>
    <td>0</td></tr>
<tr><td rowspan="2">&lt;=</td>
    <td rowspan="2">a&lt;=b</td>
    <td>True if a less than or equal b</td>
    <td>-1</td></tr>
<tr><td>False if a greater than b</td>
    <td>0</td></tr>
<tr><td rowspan="2">&gt;=</td>
    <td rowspan="2">a&gt;=b</td>
    <td>True if a greater than or equal to b</td>
    <td>-1</td></tr>
<tr><td>False if a less than b</td>
    <td>0</td></tr>
<tr><td rowspan="2">&lt;&gt;</td>
    <td rowspan="2">a&lt;&gt;b</td>
    <td>True if a not equal to b</td>
    <td>-1</td></tr>
<tr><td>False if a equal to b</td>
    <td>0</td></tr>
<tr><td rowspan="2">=</td>
    <td rowspan="2">a=b</td>
    <td>True if a equal to b</td>
    <td>-1</td></tr>
<tr><td>False if a not equal to b</td>
    <td>0</td></tr>
</tbody></table>

</p><p>You can use these-operators with a mixture of floating point or integer
values. However, if one side of the comparison is floating point, and the
other is an integer, the integer is converted to a floating point. So
if a%=1 and b=1.2, b&gt;a% is true. You can't use a mix of string and numeric
values, so a$&lt;b is invalid.

</p><p>Few programmers need the following information, so skip the rest
of the chapter if it seems daunting.

<a name="4-5a"></a></p><p>The <b>logical operators</b> AND, OR and NOT have different effects depending on
whether they are used with floating point numbers or integers:

<a name="4-5b"></a></p><p><b>1 When used with floating point numbers only,</b> the logical operators
have the following effects:

<table>
<tbody><tr><td>Example</td><td>Result</td><td>Integer Returned</td></tr>
<tr><td rowspan="2">a AND b</td>
    <td>True if both a and b are non-zero</td>
    <td>-1</td></tr>
<tr><td>False if either a or b are zero</td>
    <td>0</td></tr>
<tr><td rowspan="2">a OR b</td>
    <td>True if either a or b are non-zero</td>
    <td>-1</td></tr>
<tr><td>False if both a and b are zero</td>
    <td>0</td></tr>
<tr><td rowspan="2">NOT a</td>
    <td>True if a is zero</td>
    <td>-1</td></tr>
<tr><td>False if a is non-zero</td>
    <td>0</td></tr>
</tbody></table>

<a name="4-5c"></a></p><p><b>2 When used with integer values only</b>, AND, OR and NOT are bitwise
logical operators.

</p><p>The way the Organiser holds integer numbers internally is as a 16-bit
binary code. So, 7 looks like this: 0000000000000111
The Organiser's numerical range is +32767 to -32768. 32767 is the largest
number that can be represented with 15 binary bits. The 16th bit is used
for the + or -.

</p><p>As the operators are bitwise they perform the operation  on first the 1st
bit, then the 2nd, up to the 16th bit.

</p><p><b>AND</b> The statement PRINT 12 AND 10 prints 8. To understand this, write 12
and 10 in binary:
</p><pre><font face="Courier">  12    0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0
  10    0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0</font></pre>

<p>AND acts on each pair of bits. Thus, working from left to right -
discounting the first 12 bits:

<br>1 AND 1 --&gt;  1
<br>1 AND 0 --&gt;  0
<br>0 AND 1 --&gt;  0
<br>0 AND 0 --&gt;  0

</p><p>The result is therefore the binary number 1000, or 8.

</p><p><b>OR</b> What result would the statement PRINT 12 OR 10 give? Again, write
down the numbers in binary and apply the operator to each pair of digits:

<br>1 OR 1 --&gt;  1
<br>1 OR 0 --&gt;  1
<br>0 OR 1 --&gt;  1
<br>0 OR 0 --&gt;  0

</p><p>The result is the binary number 1110, or 14 in decimal.

</p><p><b>NOT</b> NOT works on only one number. It returns the one's complement,
i.e. it replaces 0s with 1s and 1s with 0s.

</p><p>So if 7 looks like this: 0000000000000111
<br>NOT 7 will look like this: 1111111111111000

</p><p>This is the binary representation of -8.

</p><p><b>Hint.</b> A quick way of calculating NOT for integers is to add 1 to the
original number and reverse its sign. Thus, NOT 23 is -24, NOT 0 is -1
and NOT -1 is 0. The last two results are the same for floating points.

</p><p align="center"><img src="./Psion Organiser II LZ_LZ64 Programming Manual_ Chapter 3-8_files/psibar.gif" width="312" height="24" alt="Psion bar."></p>

<a name="5-1a"></a><p><font size="5"><b>5 Handling data files</b></font>

</p><p>When you use the SAVE option from the main menu your records are saved in a
file called MAIN. You can also create extra data files in the Xfiles option.
You can access these files and the records in them from OPL. You can also
create new files and then manipulate them. This chapter explains how to
do this.

</p><pre>Record    Dr John Wood
          0982 23456
          44 Broughton Rd
          Broughton</pre>

<p>[image]

</p><p><b>There are also three examples of data file handling programs at the end of
the example procedures chapter.</b> It may be a good idea to refer to those
programs while you read this chapter.


<a name="5-2a"></a></p><p><font size="3"><b>Files, records and fields</b></font>

</p><p>The data file MAIN and any extra ones you create contain <b>records</b>
which are divided into <b>fields</b>. When you save a record from the main
menu with the SAVE option, you start a new field every time you start a new
line by pressing <b>DOWN</b>.

</p><p>In a name and address file, in each record, there might be a name field,
a telephone number field, and separate fields for each line of the address.

</p><p>[image]

</p><pre>Records     Dr John Wood
            0982 23456
            44 Broughton Rd
            Broughton

              Dr John Wood      --&gt; Field 1
Fields        098223456         --&gt; Field 2
              44 Broughton Rd   --&gt; Field 3
              Broughton         --&gt; Field 4</pre>


<a name="5-3a"></a><p><font size="4"><b>Creating a data file</b></font>

</p><p>Before you can start to enter data into a new data file, you must create
the file on one of the devices using New in Xfiles or the CREATE command
in OPL.

</p><p>With CREATE in OPL you have more control, as you specify how many fields
there can be in each record, and what type of data can go in each field.
The CREATE command has this syntax:
<br><font face="Courier">
CREATE "&lt;dev&gt;fname",logname,fldnm1,fldnm2
</font>

</p><p><b>"&lt;dev&gt;fname"</b>, is the device (A:, B: or C:) which the
file is to be on, and then the file name. This all goes in quotes as a string, e.g.
"a:clients". You can also assign this device and file name string to a
string variable (e.g. cl$="a:clients") and then use the variable name
(cl$) as the parameter. The file name may be up to 8 characters long.

<a name="5-3c"></a></p><p><b>logname</b> is the <b>logical file name</b>. This may be A, B, C or D.
You use this logical file name to refer to the file from within the program.

<a name="5-3d"></a></p><p><b>fldnm1, fldnm2</b> are the field names. There may be up to 16 fields in
any record, and these may be given a qualifier, either % or $, to signify
integer data or string data respectively. Fields containing floating point
data need no qualifier. Field names may be up to 8 characters long
including any qualifier used.

</p><p>An example of a CREATE command might be:

</p><p>CREATE "a:clients",B,nm$,tel$,ad1$,ad2$,ad3$

</p><p>When a file has been created, it is automatically open. This means records
can be saved to it immediately. It also becomes the current file which means
that when you use one of the commands for manipulating records, they operate
on this file.


<a name="5-4a"></a></p><p><font size="4"><b>Adding records to a file</b></font>

</p><p>You add records to a data file field by field. First you assign some values
to the current field names, then you use the APPEND command to add them to
the file.


<a name="5-4b"></a></p><p><font size="3"><b>Assigning values to field names</b></font>

</p><p>The field names act in a similar way to variables, and can be assigned values
and used in INPUT statements. The field name must be used with the logical
file name like this:
<br><font face="Courier">
INPUT B.name$
</font>
<br>or this
<br><font face="Courier">
B.name$="MR Bruno"
</font>

</p><p>where B is the logical file name and name$ is the name of the field. These
are separated by a full stop.


<a name="5-4c"></a></p><p><font size="3"><b>Appending the fields</b></font>

</p><p>When you have assigned values to the fields, you add them to the open file
with the <b>APPEND</b> command. They are always added as the last record in the
data file. If the file is a new one, this will be the first record.

</p><p>The APPEND command has no parameters - the field values are automatically
added to the file in the correct order and format.

</p><p>If you try to assign a text string to a numeric field name, an error will
be reported.

</p><p><b>See the second procedure (insert:) in program no. 6 of Chapter 8 for an
example of adding records to a data file.</b>

</p><p>At any time while a data file is open, the field names currently in use
can be used like any other variable - for example, in a PRINT statement,
or a string or numeric expression. However, in order to operate on a
particular field, you must make the record containing it the current one.


<a name="5-5a"></a></p><p><font size="4"><b>Changing the current record</b></font>

</p><p>Before you can erase a record or operate on the fields in it you must make
it current. You can change the current record by using any of the six
commands and functions below.

</p><p><b>FIRST</b> moves to the first record in a file.

</p><p><b>NEXT</b> moves to the following record in a file. If the end of the file is
passed, <b>NEXT</b> does not report an error. The current record will then be
null. This condition can be tested for with the EOF function.

</p><p><b>BACK</b> moves to the previous record in the file. If the current record is
the first record in the file then the current record does not change.

</p><p><b>LAST</b> moves to the last record in the file.

</p><p><b>POSITION</b> moves to a particular record. For example, the
instruction POSITION 3 makes record 3 (the first record is record 1)
the current record. You can find the current record number by using
the POS function which returns the number of the current record.

</p><p><b>FIND</b> moves to the record which contains a search string you specify.


<a name="5-6a"></a></p><p><font size="3"><b>Finding a record</b></font>

</p><p>The FIND function acts like the main menu Find, but without wild cards.
The difference is that whereas the main menu Find prints the record on the
screen, this function makes it the current record so that you can operate
on it: editing it, erasing it, or just displaying it.

</p><p>For example, the line
<br><font face="Courier">
r%=FIND("HOLMES")
</font>
<br>would make the first record. containing the string "HOLMES" the current
record and return the number of that record to the variable r%. If the
number returned is zero, the string was not found.

</p><p>There is another function, FINDW, which is the same as FIND but does allow
wild cards. So, to find the first record containing ORDER and 89 use this
instruction:
<br><font face="Courier">
r%=FINDW("*ORDER*89*")
</font>
</p><ul>+ Matches any character.
<br>* Matches any group of characters.</ul>

<p>The procedure called search: in program no. 6 in Chapter 8 is an example
of how to find and edit records.


<a name="5-6b"></a></p><p><font size="3"><b>Erasing a record</b></font>

</p><p>To erase a record, make that record current by use of one of the commands
FIRST, NEXT, BACK, LAST, POSITION or FIND and then use the ERASE command.
This removes the current record from the file and renumbers the ones that
follow.

</p><p>The final procedure (erase:) in program no. 6 in Chapter 8 is an example of
how to find and erase records.


<a name="5-7a"></a></p><p><font size="4"><b>Opening a file</b></font>

</p><p>When you first CREATE a data file it is automatically open but it closes
again when the program ends. To open the file again in another program, you
use the OPEN command.

</p><p>The syntax of the OPEN command is the same as for the CREATE command. You
must use the same device and file name as when you first created it, but
when opening it in a different program, you can give it a different logical
file name and give the fields different names. For example, a file which was
created in one program with the command:
<br><font face="Courier">
CREATE "c:address",D,name$,num$,add$,add2$
</font>
<br>can be opened in another program by the command:
<br><font face="Courier">
OPEN "c:address",A,a$,b$,c$,d$
</font>

</p><p>Up to four files may be open at any one time, and these may be spread over
any of the three devices. Each must be referred to in the program by a
different logical name. So, if you have 4 files open. one is A one is B one
is C and the other is D.

</p><p>If you are going to edit or erase records in the file. you need to include
all the fields you are going to operate on in the OPEN command. However, if
you are just going to search for strings and display records. you only need
to include the first field in the OPEN command, like this:
<br><font face="Courier">
OPEN "c:address",A,a$
</font>

<a name="5-8a"></a></p><p><font size="4"><b>Changing the current file</b></font>

</p><p>When a file is created or opened, that file is then automatically the
current file and all access is to that file until you say you want to USE a
different one. The <b>USE</b> command makes a file current. You refer to the
file by its logical file name. For example:
<br><font face="Courier">
USE B
</font>

</p><p>In this example the file with the logical file name B (as specified in the
OPEN or CREATE command which opened it) becomes the current file. All access
is now to this file until you change the current file with another USE
command or OPEN or CREATE another file. If you attempt to use a file which
has not previously been opened, an error is reported.


<a name="5-8b"></a></p><p><font size="3"><b>Closing and deleting a file</b></font>

</p><p>Data files close automatically when programs end. However, when you have
finished accessing a particular file, you can close it with the CLOSE
command which closes the current file.

</p><p>You might want to close a file if you already have 4 files open in a
program, and you want to open another, or if you want to delete the file.
There is a command <b>DELETE</b> for deleting data files, but the file to be
deleted must be closed first.


</p><p><font size="3"><b>More information on data file handling</b></font>

</p><p>See the beginning of Chapter 9 for a summary of all the data file handling
commands and functions. Then look up each one for more detail.

</p><p>Look at programs 6, 7 and 8 in Chapter 8 for examples of data file handling
programs.

</p><p align="center"><img src="./Psion Organiser II LZ_LZ64 Programming Manual_ Chapter 3-8_files/orgbar.gif" width="312" height="24" alt="Organiser bar."></p>

<a name="6-1a"></a><p><font size="5"><b>6 Handling any type of file</b></font>

</p><p>Most of the file handling commands and functions are only for data files.

</p><p>However there are three, COPYW, DELETEW and DIRW$, which operate on any
type of file. You indicate the type of file with these extensions:

<table>
<tbody><tr><td><font face="Arial" size="2">Data file and diary file<br>
(ODB stands for Organiser Data Base.)</font></td>
    <td><font face="Arial" size="2"><b>.ODB</b></font></td></tr>
<tr><td><font face="Arial" size="2">OPL procedure</font></td>
    <td><font face="Arial" size="2"><b>.OPL</b></font></td></tr>
<tr><td><font face="Arial" size="2">Notepad file</font></td>
    <td><font face="Arial" size="2"><b>.NTS</b></font></td></tr>
<tr><td><font face="Arial" size="2">Comms Link setup file</font></td>
    <td><font face="Arial" size="2"><b>.COM</b></font></td></tr>
<tr><td><font face="Arial" size="2">Spreadsheet file</font></td>
    <td><font face="Arial" size="2"><b>.PLN</b></font></td></tr>
<tr><td><font face="Arial" size="2">Pager setup file</font></td>
    <td><font face="Arial" size="2"><b>.PAG</b></font></td></tr>
<tr><td><font face="Arial" size="2">Diary file from XP or CM</font></td>
    <td><font face="Arial" size="2"><b>.DIA</b></font></td></tr>
</tbody></table>

</p><p>There are also two extra extensions for COPYW only. Use these to copy only
one part of an OPL procedure.

<table>
<tbody><tr><td><font face="Arial" size="2">OPL procedure (text only)</font></td>
    <td><font face="Arial" size="2"><b>.OPT</b></font></td></tr>
<tr><td><font face="Arial" size="2">OPL procedure (object only)</font></td>
    <td><font face="Arial" size="2"><b>.OPO</b></font></td></tr>
</tbody></table>

</p><p>You can also use wild cards with COPYW, DELETEW and DIRW$. The wild cards
are the normal ones: + is any character, * is any group of characters.


</p><p><font size="3"><b>Examples</b></font>

</p><p><font face="Courier">
COPYW "A:*88.OPL","B:"
</font><br>
Copies all the OPL procedures whose names end in 88 from A: to B:

</p><p><font face="Courier">
DELETEW "C:*.NTS"
</font><br>
Deletes an the notepad files on C:

</p><p><font face="Courier">
DIRW$ ("A: R*")
</font><br>
Returns the name of the first file of any type on A: which starts with
the letter R.


<a name="6-2a"></a></p><p><font size="3"><b>Diary files</b></font>

</p><p>Diary files are saved as data files. Each entry is a record
with this two field format:
<table><tbody><tr><td bgcolor="silver"><font face="Courier">
1989042712000100&nbsp;&nbsp;&nbsp;&nbsp;<br>
JAMES BIRTHDAY
</font></td></tr></tbody></table>

</p><p>in this example, the first field carries this information:

<table>
<tbody><tr><td><b>1989</b></td>
    <td><font face="Arial" size="" 2="">The year</font></td></tr>
<tr><td><b>04</b></td>
    <td><font face="Arial" size="" 2="">The month</font></td></tr>
<tr><td><b>27</b></td>
    <td><font face="Arial" size="" 2="">The date</font></td></tr>
<tr><td><b>1200</b></td>
    <td><font face="Arial" size="" 2="">The start time</font></td></tr>
<tr><td><b>01</b></td>
    <td><font face="Arial" size="" 2="">The duration - one 15 minute interval</font></td></tr>
<tr><td><b>00</b></td>
    <td><font face="Arial" size="" 2="">The alarm pre-warning time. In this case there is no alarm so it's zero.</font></td></tr>
</tbody></table>


</p><p>You can open a saved diary file in Xfiles, and then find and update records
in it. For example, you could find all your annual entries such as
birthdays and change 1989 to 1990. If you then restored the diary and
merged it with the current one you wouldn't need to put in all the birthday
entries again at the end of the year. However, be careful to use the right
format, or you won't be able to restore the diary.

</p><p>You could also do this in OPL using the data file handling and string
handling commands. There is a program in Chapter 8 which does this.

</p><p align="center"><img src="./Psion Organiser II LZ_LZ64 Programming Manual_ Chapter 3-8_files/psibar.gif" width="312" height="24" alt="Psion bar."></p>

<a name="7-1a"></a><p><font size="5"><b>7 Error handling</b></font>

</p><p>This chapter covers commonly made errors, then error trapping. There is a
list of the OPL error messages in Appendix D.


</p><p><font size="4"><b>Common errors</b></font>

</p><p>All programming languages are very particular about the way commands and
functions are used, especially in the way program statements are laid out.

</p><p>Below are a number of errors which are easy to make in OPL. The incorrect
statements are in bold and the correct versions are on the right.

</p><p><b>Punctuation errors</b>

</p><p>Omitting the colon between statements on a multi-statement line:
<table>
<tbody><tr><td><font face="Arial" size="2">Incorrect</font>
</td><td><font face="Arial" size="2">Correct</font></td></tr>
<tr><td><font face="Courier"><b>a$="text" PRINT a$</b></font>
</td><td><font face="Courier">a$="text" :PRINT a$</font></td></tr>
</tbody></table>

</p><p>Omitting the colon after a called procedure name:
<table>
<tbody><tr><td><font face="Arial" size="2">Incorrect</font>
</td><td><font face="Arial" size="2">Correct</font></td></tr>
<tr><td><font face="Courier">
proc1:<br>GLOBAL a,b,c<br>.<br>.<br><b>proc2</b>
</font></td><td><font face="Courier">
proc1:<br>GLOBAL a,b,c<br>.<br>.<br>proc2:
</font></td></tr></tbody></table>


</p><p>Omitting one or more of the colons after a label:
<table>
<tbody><tr><td><font face="Arial" size="2">Incorrect</font>
</td><td><font face="Arial" size="2">Correct</font></td></tr>
<tr><td><font face="Courier">
proc1:<br><b>GOTO below:</b><br>.<br>.<br>below::
</font></td><td><font face="Courier">
proc1:<br>GOTO below::<br>.<br>.<br>below::
</font></td></tr></tbody></table>

</p><p>Omitting the space before the colon between statements on a multi-statement
line:

<table>
<tbody><tr><td><font face="Arial" size="2">Incorrect</font>
</td><td><font face="Arial" size="2">Correct</font></td></tr>
<tr><td><font face="Courier">
proc1:<br><b>a$=b$:PRINT a$</b>
</font></td><td><font face="Courier">
proc1:<br>a$=b$: PRINT a$
</font></td></tr></tbody></table>


</p><p>Parameter errors
Passing a floating point value to a procedure which requires an integer -
here the procedure proc2:(x%).
<table>
<tbody><tr><td><font face="Arial" size="2">Incorrect</font>
</td><td><font face="Arial" size="2">Correct</font></td></tr>
<tr><td><font face="Courier">
<b>2*6+proc2:(PI)</b>
</font></td><td><font face="Courier">
2*6+proc2:(INT(PI))
</font></td></tr></tbody></table>



</p><p>This may also happen when a procedure is called from the calculator. The
calculator converts all numbers to floating point, so:
<table>
<tbody><tr><td><font face="Arial" size="2">Incorrect</font>
</td><td><font face="Arial" size="2">Correct</font></td></tr>
<tr><td><font face="Courier">
Calc:<b>proc2:(3)</b>
</font></td><td><font face="Courier">
Calc:proc2:(INT(3))
</font></td></tr></tbody></table>


</p><p>Passing an integer to a procedure which requires a floating point value -
here the procedure proc3:(x)
<table>
<tbody><tr><td><font face="Arial" size="2">Incorrect</font>
</td><td><font face="Arial" size="2">Correct</font></td></tr>
<tr><td><font face="Courier">
proc1:<br>.<br>.<br><b>proc3:(2/3)</b>
</font></td><td><font face="Courier">
proc1:<br>.<br>.<br>proc3:(2.0/3)
</font></td></tr></tbody></table>


</p><p>Passing the wrong number of parameters to a procedure - here, the
procedure proc4:(x,y)
<table>
<tbody><tr><td><font face="Arial" size="2">Incorrect</font>
</td><td><font face="Arial" size="2">Correct</font></td></tr>
<tr><td><font face="Courier">
proc1:<br>.<br>.<br><b>proc4:(3.7)</b>
</font></td><td><font face="Courier">
proc1:<br>.<br>.<br>proc4:(3.7,2.5)
</font></td></tr></tbody></table>


</p><p><b>Integer size error</b>

</p><p>OPL only allows numbers between minus 32768 and plus 32767 to
be assigned to integer variables, so any expression which exceeds
these limits will cause an error:
<table>
<tbody><tr><td><font face="Arial" size="2">Incorrect</font>
</td><td><font face="Arial" size="2">Correct</font></td></tr>
<tr><td><font face="Courier">
proc1:<br>LOCAL <b>a%<br>a%=100*2468</b>
</font></td><td><font face="Courier">
proc1:<br>LOCAL a<br>a=100.0*2468
</font></td></tr></tbody></table>

</p><p><b>Structure errors</b>

</p><p>The structures allowed within OPL are DO/UNTIL, WHILE/ENDWH and
IF/ELSEIF/ELSE/ENDIF. These may all be nested within one another to up
to eight structures deep. Attempting to nest to a greater depth than this
will cause an error. Mixing up the three structures e.g. by matching up DO
with WHILE, will also cause an error:

<table>
<tbody><tr><td><font face="Arial" size="2">Incorrect</font>
</td><td><font face="Arial" size="2">Correct</font></td></tr>
<tr><td><font face="Courier">
proc1:<br>.<br>DO<br>.<br><b>WHILE</b> a&lt;2
</font></td><td><font face="Courier">
proc1:<br>.<br>DO<br>.<br>UNTIL a&gt;=2
</font></td></tr></tbody></table>


<a name="7-4a"></a></p><p><font size="4"><b>Run-time errors</b></font>

</p><p>If an error occurs when you run a program, the program stops
and an error message is displayed.

</p><p>If you are running the procedure from the main menu, just press
<b>SPACE</b> to return to the menu.

</p><p>However if you are running it from the Prog menu, you get a chance
to edit it. Here a call has been made to a procedure called subproc:
which does not exist:

<table><tbody><tr><td bgcolor="silver"><font face="Courier">
&nbsp;&nbsp;&nbsp;&nbsp;MISSING PROC<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SUBPROC<br>
....................<br>
Edit A:MAINPROC Y/N
</font></td></tr></tbody></table>

</p><p>Press <b>Y</b> if you want to edit the procedure. If the source
code is available, you are returned to the OPL editor to
correct the offending line. Press <b>N</b> or <b>ON/CLEAR</b> if you
don't want to edit it.

</p><p>When you have done this, press MODE to get the
editor menu, and either translate, save or quit the
procedure. If you quit, the edits you have made this
session are abandoned.


<a name="7-4b"></a></p><p><font size="4"><b>Error trapping</b></font>

</p><p>In the case of the run time errors described above, the program stops
to display the error message. There are ways of avoiding this by
trapping errors and dealing with them yourself within the program -
but they put you in full control and <b>must be used carefully</b>. The
tools used to control errors are <b>ONERR</b>, <b>TRAP</b>, <b>ERR</b>,
<b>ERR$</b> and <b>RAISE</b>:
</p><ul><li>ONERR traps any errors which occur and redirects the program to
      your own error handler.</li>
    <li>TRAP traps only errors on a particular command.</li>
    <li>ERR and ERR$ identify which error has occurred.</li>
    <li>RAISE generates an error. (often used for testing)</li></ul>


<a name="7-5a"></a><p><font size="3"><b>ONERR label:: and ONERR OFF</b></font>

</p><p>ONERR, is used to redirect program control to a label if an error
occurs. This is useful if you want to provide your own error handling
routine, such as printing out a message for an error you anticipate.
ONERR is followed by the label name which ends in two colons. The
label itself can be either in the same procedure or in a procedure before
it in the same program.

</p><p>In the example below, LPRINT is being used to print to an attached
printer. Normally, when no printer is connected, the message
DEVICE MISSING is displayed. Here a more precise message,
CONNECT PRINTER, is supplied by the programmer:

<font face="Courier">
</font></p><p><font face="Courier">ONERR noprint::
<br>LPRINT "Dear Sir"
<br>RETURN
<br>noprint::
<br>ONERR OFF :IF ERR=194 :RAISE ERR :ENDIF
<br>PRINT "CONNECT PRINTER"
<br>GET</font>

</p><p>The first line causes a jump to the label noprint:: if an error occurs. If
no printer is connected, the LPRINT command causes such a jump and the
message "CONNECT PRINTER" is displayed. If there is one connected, "Dear Sir"
is printed and the lines after the label are never run, because of the RETURN
before it.
</p><ul><li><b>You should always cancel ONERR with ONERR OFF as soon as an error has
      been detected.</b></li>
    <li><b>You should always deal with the LOW BATTERY error explicitly as it is
      so important.</b></li></ul>


<p><font size="3"><b>ONERR OFF</b></font>

</p><p>Notice that the first instruction after the label noprint:: is ONERR
OFF. This is very important because if you don't do this after the
ONERR label:: command is used, all subsequent program errors -
even in other procedures called - result in the program being directed
to the same label. This diagram illustrates how two completely
different errors cause a jump to the same label, and cause the same
explanatory message to be printed out:

<font face="Courier">
</font></p><p><font face="Courier">proc1:
<br>onerr label::
<br>....
<br>a=log(- 1)
<br>....
<br>label::
<br>PRINT "Explanation of log error"
<br>....
  </font></p><ul><font face="Courier"><b>proc2:</b>
  <br>....
    <ul><b>proc3:</b>
    <br>PRINT 2/0</ul>
  </font></ul><font face="Courier">
</font>

<p><font size="3"><b>Risks of ONERR label::</b></font>

</p><p>As all errors go back to the same label unless you switch ONERR
OFF, it is very easy to create an endless loop by mistake. If this
happens, you cannot press <b>ON/CLEAR</b> and <b>Q</b> to break out, as this
just makes control go to the label as any other error would - so, you
have to take the battery out of the Organiser, and lose everything in
the internal memory. To avoid this:
</p><ul><li><b>You should always include the command ONERR OFF immediately after
      the label.</b></li></ul>


<a name="7-7a"></a><p><font size="3"><b>TRAP</b></font>

</p><p>TRAP traps errors on a specified command only, so it doesn't need
to be cancelled like ONERR does. It can be used with any of the
commands listed below:

</p><p>APPEND BACK CLOSE COPY COPYW CREATE DELETE DELETEW ERASE
EDIT FIRST INPUT LAST NEXT OPEN POSITION RENAME UPDATE USE

</p><p>The trap command immediately precedes any of these commands, separated from
it by a space - e.g:
<br><font face="Courier">
TRAP INPUT a%
</font>

</p><p>When INPUT is used without TRAP and a text string is entered
when a number is required, the display just scrolls up and a question
mark is shown, prompting for another - valid - entry. When you put
TRAP in front of INPUT, the command is executed in the usual way,
but if an error occurs the next line of the program is executed as if
there had been no error. The next line in the example below is a
helpful message.

<font face="Courier">
</font></p><p><font face="Courier">proc:
<br>LOCAL a%
<br>start::
<br>PRINT "ENTER AGE",
<br>TRAP INPUT a%
<br>IF ERR=252
<br> PRINT "NUMBER NOT WORD"
<br> GOTO start::
<br>ENDIF</font>

</p><p>The example above also uses the ERR function.


<a name="7-8a"></a></p><p><font size="3"><b>The ERR function</b></font>

</p><p>When errors occur in a program, the number of the error is accessible
by using the <b>ERR</b> function. This means that you can be absolutely
sure which error you are dealing with.

</p><p>The anticipated error in the lines below is 246 (NO PACK). If 246
occurs when trying to open the MAIN file on pack B: a helpful
error message is printed out. However, just in case a different error
occurs, the next lines make sure that the standard error message for
that error is printed.

<font face="Courier">
</font></p><p><font face="Courier">TRAP OPEN "B:MAIN",A,a$
<br>IF ERR=246
<br> PRINT "NO PACK IN B:"
<br>ELSEIF ERR
<br> PRINT ERR$(ERR)
<br>ENDIF</font>

</p><p>The OPL error messages are listed in Appendix D.


<a name="7-8b"></a></p><p><font size="3"><b>RAISE</b></font>

</p><p>If you are using commands to trap errors and handle them yourself,
then at some during the development stage of your program you need
to test your error handling routines. An easy way to do this is with the
RAISE command. You can generate an error that you think might
occur when the program is in use, and see if the error handling routine
takes care of it in the way you anticipate. For example, this statement
causes the NO PACK error to be generated:

</p><p><font face="Courier">RAISE 246</font>

</p><p align="center"><img src="./Psion Organiser II LZ_LZ64 Programming Manual_ Chapter 3-8_files/orgbar.gif" width="312" height="24" alt="Organiser bar."></p>

<a name="8-1a"></a><p><font size="5"><b>8 Example programs</b></font>

</p><p>This chapter contains example programs written in OPL. The
programs are not intended to demonstrate all the features of OPL, but
they should give you a few hints. To find out more about a particular
command or function, refer to Chapter 9. Each of the procedures must
be entered separately, you can't enter two procedures in one block.
Chapter 1 explains how to type in, translate, save and run a
procedure.


</p><p><b>Uppercase, lowercase</b>

</p><p>In the listings here, variables are shown in lowercase and commands
and functions in uppercase. However, it doesn't matter which you
use when you enter procedures into the Organiser:
</p><ul><li><b>You can type procedures in an uppercase, all lowercase or any mixture
      of the two.</b></li></ul>


<p><b>Spaces</b>

</p><p>Be careful to type in the necessary spaces:
</p><ul><li>When there is more than one command or function on a line, you
      need to separate each one with a space. Also each command or
      function except for the first must have a colon before it - for
      example:</li>
<br><font face="Courier">
CLS :PRINT "hello" :GET
</font>
    <li>Put a space between a command and the arguments which follow it - for
      example:</li>
<br><font face="Courier">
LOCAL a$
</font>
    <li>Don't put a space between a function and the arguments in brackets -
      for example:</li>
<br><font face="Courier">
CHR$(16)
</font>
    <li>It doesn't matter how many spaces you have at the beginning of a line.</li></ul>


<p><b>Remarks</b>

</p><p>Lines beginning with the command REM are remarks; they are there to explain
things. They do not affect the way a procedure runs and you don't have to
type them in if you don't want to.


</p><p><font size="3"><b>1 Days (Version 1)</b></font>

</p><p>This procedure works out the number of days you've been alive. Substitute
your own date of birth for the one supplied here.

</p><pre><font face="Courier">days1:
LOCAL birth%,now%,answer%
birth%=DAYS(14,6,1957)
now%=DAYS(DAY,MONTH,YEAR)
answer%=now%-birth%
PRINT answer% :GET</font></pre>

<p><b>Variables</b>
<br><b>birth%</b> is your date of birth.
<br><b>now%</b> is the current date.
<br><b>answer%</b> is the current date minus your date of birth.


</p><p><b>Date functions</b>
<br>All the OPL date functions return values accessed from the Organiser
clock and calendar. The function DAYS returns the number of days
since the beginning of the calendar on a particular date.


</p><p><font size="3"><b>2 Days (Version 2)</b></font>

</p><p>This procedure is a more flexible one which works out the number of days
between boy two dates that you input. When you run the procedure you are
prompted to enter the day, month and year of the first date then the
second date.

</p><pre><font face="Courier">days2:
LOCAL d1%, m1%, y1%, d2%, m2% y2%
PRINT "ENTER FIRST DAY"
INPUT d1%
PRINT "ENTER FIRST MONTH"
INPUT m1%
PRINT "ENTER FIRST YEAR"
INPUT y1%
PRINT "ENTER SECOND DAY"
INPUT d2%
PRINT "ENTER SECOND MONTH"
INPUT m2%
PRINT "ENTER SECOND YEAR"
INPUT y2%
PRINT DAYS(d2%,m2%,y2%)-DAYS(d1%,m1%,y1%)
GET</font></pre>


<p><b>Variables</b>
<br><b>d1%</b>, <b>m1%</b> and <b>y1%</b> are the day month and year of the first date.
<br><b>d2%</b>, <b>m2%</b> and <b>y2%</b> are the day month and year of the second date.


</p><p><font size="3"><b>3 Dice</b></font>

</p><p>This procedure turns the Organiser into a dice. When the program is
run, a message is displayed saying that the dice is rolling. You then
press S to stop it. A random number from one to six is displayed and
you choose whether to roll again or not.

</p><pre><font face="Courier">dice:
LOCAL dice%,key%
KSTAT 1
top::
CLS :PRINT "****DICE ROLLING****"
PRINT "PRESS S TO STOP"
DO
 dice%=(RND*6+1)
UNTIL KEY$="S"
CLS
PRINT "********* ";dice%;" ********"
BEEP 50,100
AT 1,4 :PRINT "ROLL AGAIN Y/N"
label::
key%=GET
IF key%=%Y
 GOTO top::
ELSEIF key%=%N
 RETURN
ELSE
 GOTO label::
ENDIF</font></pre>


<p><b>Variables</b>
<br><b>dice%</b> is a random number from 1 to 6.
<br><b>key%</b> is the ASCII value of the keypress read by the GET function.


</p><p><b>Random numbers</b>
<br>This is how dice: displays 1, 2, 3, 4, 5 or 6 randomly. The RND
function returns a random floating point number, between 0 and 1
(not including 1). It is then multiplied by 6 and 1 is added (so that
you get numbers from 1 to 6 instead of from 0 to 5). It is rounded
down to a whole number by assigning to the integer dice%.


</p><p><b>Identifying keypresses of Y and N</b>
<br>The ASCII value of the character on the key you press is returned by
the GET function and assigned to key%. In OPL you get the ASCII
value of any character by putting % in front of it, so %Y is the ASCII
value of Y and %N is the ASCII value of N. In case you had the
keyboard set to lowercase, KSTAT 1 is used at the start of the
procedure to set it to uppercase, so that you are not pressing y and n.


</p><p><font size="3"><b>4 Mortgage calculator</b></font>

</p><p>This program calculates monthly mortgage payments. When you run
it, you have to enter the amount of the loan, the interest rate and the
term in years. Then you specify the source of the loan by selecting
from a menu. The program does not allow for tax relief.

</p><p>The program is made up to two procedures - mortgage: and q: - a
general input routine. You must type each one in separately. The
input routine could be called by any procedure which needs to
prompt the user to enter a floating point number.

</p><pre><font face="Courier">mortgage:
LOCAL num%,loan,x,term,rate,pay,ques$(2)
CLS
PRINT "EVALUATE MONTHLY"
PRINT "MORTGAGE PAYMENT"
PAUSE 30
ques$=CHR$(63)+" "
REM CHR$(63) is a "?" - See Appendix A
loan=q:("ENTER LOAN"+ques$)
DO
 rate=q:("INTEREST RATE % "+ques$)
UNTIL rate&gt;0 AND rate&lt;99
DO
 term=q:("ENTER TERM (YRS)"+ques$)
UNTIL term&gt;.5 AND term&lt;100
num%=MENU("BUILDING-SOCIETY,BANK,OTHER")
IF num%=0 :RETURN :ENDIF
rate=rate/100 :x=1+11*(num%/2)
pay=loan*rate/12/(1-((1+rate/x)**(-x*term)))
CLS :PRINT "MONTHLY PAYMENT"
PRINT FIX$(pay, 2, -8)
GET
RETURN
<a name="8-7a"></a>
q:(a$)
LOCAL z
CLS :PRINT a$,CHR$(16);
INPUT z
CLS
RETURN(z)</font></pre>

<p><b>Variables</b>
<br><b>loan</b>, <b>term</b>, <b>rate</b> and <b>pay</b> are the amounts of
the loan, the term in years, the interest rate and the monthly payments.
<br><b>ques$</b> is "? ".
<br><b>num%</b> is the number of the menu item you choose.
<br><b>x</b> is a variable used in the calculation at the end.
<br><b>z</b> is the variable used for the values you input when q: is running.

</p><p><b>Calling q:</b>
<br>The main procedure mortgage: calls q: three times, passing it a string to
be printed out as a prompt. The text string is passed to q: as a parameter.
The values returned are assigned to the variables loan, rate, and term.

</p><p><b>How "?" is printed</b>
<br>The CHR$ function converts the ASCII value 63 to the question mark character.


</p><p><b>How the input routine beeps</b>
<br>The CHR$ function converts the value 16 to the beep control character. This
is then "printed" out.


<a name="8-8a"></a></p><p><font size="3"><b>5 Chase Game</b></font>

</p><p>The next two procedures make up a game which demonstrates the use of user
defined graphics (UDG's). Each procedure must be typed in separately.

</p><p>The object of the game is to avoid being caught by the pursuers. Your
movable man can jump up and down: press the <b>X</b> key to jump down and the
<b>S</b> key to jump up. At the end of the game your score will be displayed
on the screen.

</p><p>To pause the game, press <b>ON/CLEAR</b> and to restart press it again. To quit
out of the game press <b>ON/CLEAR</b> then <b>Q</b>.

</p><pre><font face="Courier">game:
LOCAL e$ (2)
LOCAL a%,b%,b1%,c%,c1%,x%,y%,i%,sc%
graphic: :CURSOR OFF
e$=CHR$(4)+CHR$(6)
b%=20 :c%=12 :x%=3 :y%=1
DO
 CLS :PRINT REPT$(CHR$(158),80)
 AT x%,y% :PRINT CHR$(7)
 a%=1 :c%=1+RND*4
 DO :c1%=1+RND*4 :UNTIL c%&lt;&gt;c1%
 DO
  AT a%,c% :PRINT CHR$(0)
  AT a%,c1% :PRINT CHR$(0) :BEEP b%,10*b%
  AT a%,c% :PRINT CHR$(1)
  AT a%,c1% :PRINT CHR$(1) :BEEP b%,10*b%
  AT a%,c% :PRINT CHR$(2)
  AT a%,c1% :PRINT CHR$(2) :BEEP b%,10*b%
  AT a%,c% :PRINT CHR$(3)
  AT a%,c1% :PRINT CHR$(3) :BEEP b%,10*b%
  AT a%,c% :PRINT e$
  AT a%,c1% :PRINT e$ :BEEP b%,10*b%
  AT a%,c% :PRINT CHR$(5)
  AT a%,c1% :PRINT CHR$(5) :BEEP b%,10*b%
  AT a%,c% :PRINT " " :AT a%,c1% :PRINT " "
  i%=KEY
  IF i%
   IF i%=%S AND y%&gt;1
    AT x%,y% :PRINT CHR$(158)
    y%=y%-1 :AT x%,y% :PRINT CHR$(7)
   ENDIF
   IF i%=%X AND y%&lt;4
    AT x%,y% :PRINT CHR$(158)
    y%=y%+1 :AT x%,y% :PRINT CHR$(7)
   ENDIF
  ENDIF
  a%=a%+1
  IF a%=x% AND (c%=y% OR c1%=y%) :REM Hit
   i%=0
   DO
    AT x%,y% :PRINT CHR$(170+i%)
    BEEP 10,100+i%
    i%=i%+1
    BEEP 10,100-i%
   UNTIL i%=30
   b%=b%+5 :a%=20 :x%=x%+2
   IF x%&gt;20
    CLS :PRINT "GAME OVER"
    PRINT "SCORE:",sc% :PAUSE 40
    WHILE KEY :ENDWH :REM Drain buffer
    GET :RETURN
   ENDIF
  ENDIF
 UNTIL a%=20
 sc%=sc%+1
 IF b%&gt;12
  b%=b%-2
 ELSEIF b%&lt;6
  IF b1%
   b%=b%-1 :b1%=0
  ELSE
   b1%=1
  ENDIF
 ELSE
  b%=b%-1
 ENDIF
UNTIL 0

graphic:
UDG 0,0,0,28,30,30,30,28,0
UDG 1,0,0,14,31,30,31,14,0
UDG 2,0,0,7,14,12,14,7,0
UDG 3,0,0,3,7,6,7,3,0
UDG 4,0,0,1,3,3,1,0,0
UDG 5,0,0,0,1,1,1,0,0
UDG 6,0,0,24,16,4,16,24,0
UDG 7,30,14,4,14,30,14,11,25</font></pre>


<p><b>User defined graphics</b>
<br>The main procedure, game:, calls graphic: which then uses the UDG
command 8 times to set up the graphics characters used in the game.
The last UDG command is the one which sets up the little man. User
defined characters are explained in Appendix A.


<a name="8-11a"></a></p><p><font size="3"><b>6 Data file handling procedures</b></font>

</p><p>The main procedure below creates a data file called addr on device A,
to contain names, addresses, post codes and telephone numbers. It is
followed by 4 other procedures which allow you to insert. search for,
alter and erase records in the file. When you run files:, a menu giving
you a choice of these options is displayed.

</p><p>Each of these 5 procedures must be typed in separately.

</p><pre><font face="Courier">files:
LOCAL m%
IF NOT EXIST("A:addr")
 CREATE "A:ADDR",A,n$,ad1$,ad2$,ad3$,pc$,tel$
ELSE
 OPEN " A:ADDR",A,n$,ad1$,ad2$,ad3$,pc$,tel$
ENDIF
DO
 m%=MENU("INSERT,SEARCH,ALTER,ERASE,QUIT")
 IF m%=0 or m%=5 :STOP
 ELSEIF m%=1 :insert:
 ELSEIF m%=2 :search:
 ELSEIF m%=3 :alter:
 ELSEIF m%=4 :erase:
 ENDIF
UNTIL 0 :REM do loop forever

insert:
PRINT "ENTER NAME" :INPUT A.n$
CLS :PRINT "ENTER STREET" :INPUT A.adl$
CLS :PRINT "ENTER TOWN" :INPUT A.ad2$
CLS :PRINT "ENTER COUNTY" :INPUT A.ad3$
CLS :PRINT "ENTER PCODE" :INPUT A.pc$
CLS :PRINT "ENTER TELNUM" :INPUT A.tel$
APPEND

search:
LOCAL recnum%,search$(30)
top::
FIRST :CLS :PRINT "FIND:";
TRAP INPUT search$
IF ERR=206
 RETURN
ENDIF
recnum%=FIND(search$)
IF recnum%=0
 CLS :PRINT "NOT FOUND" :PAUSE 20
 GOTO top::
ENDIF
DO
 DISP(-1,"") :NEXT :recnum%=FIND(search$)
 IF recnum%=0 :CLS
  PRINT " NO MORE ENTRIES"
  PAUSE 20 :RETURN
 ENDIF
UNTIL 0

alter:
LOCAL recnum%,search$(30),k%
DO
 FIRST :CLS
 PRINT "ALTER:"; :TRAP INPUT search$
 IF ERR=206 :RETURN :ENDIF
 recnum%=FIND(search$)
 IF recnum%=0
  CLS :PRINT "NOT FOUND"
  PAUSE 20 :CONTINUE
 ENDIF
 DO
  KSTAT 1 :CLS :AT 1,2 :PRINT "EDIT Y/N"
  k%=VIEW(1,A.n$)
  IF k%=%Y :CLS
   EDIT A.n$ :EDIT A.ad1$
   EDIT A.ad2$ :EDIT A.ad3$
   EDIT A.pc$ :EDIT A.tel$ :UPDATE :RETURN
  ELSEIF k%=%N :NEXT :recnum%=FIND(search$)
   IF recnum%=0
    CLS :PRINT "NOT FOUND" :PAUSE 20 :BREAK
   ENDIF
  ENDIF
 UNTIL 0
UNTIL 0

erase:
LOCAL recnum%,search$(30),k%
FIRST :CLS :PRINT "ERASE:";
TRAP INPUT search$
IF ERR=206 :RETURN :ENDIF
recnum%=FIND(search$)
DO
 IF recnum%=0
  CLS :PRINT "NOT FOUND" :PAUSE 20 :RETURN
 ENDIF
 ask::
 KSTAT 1 :AT 1,2 :PRINT "ERASE Y/N"
 k%=VIEW(1,A.n$)
 IF k%&lt;&gt;%Y AND k%&lt;&gt;%N
  GOTO ask::
 ELSEIF k%=%Y
  ERASE
 ELSEIF k%=%N
  NEXT :recnum%=FIND(search$)
 ENDIF
UNTIL EOF</font></pre>

<p><b>Variables</b>
<br><b>m%</b> is the number of the menu item you select
<br><b>recnum%</b> is the record number returned by FIND.
<br><b>search$</b> is the search clue you enter.
<br><b>k%</b> is the ASCII value of the key you press whilst the found record is
displayed. (%Y is the ASCII value of Y, %N is the ASCII value of N.)

</p><p><b>Creating the data file</b>
<br>The first procedure, files:, creates or opens a file called addr on device
A: with 6 fields for each record. The six field names are n$ for the
name, ad1$, ad2$, and ad$3 for each line of the address, pc$ for the
post code and tel$ for the phone number. The file is given the logical
name A.

</p><p><b>Inserting records</b>
<br>Notice how in insert: the 6 fields of the record are input one by one.
The field names are used like variables and preceded by the logical file
name (A) and a full stop. Then the APPEND command is used; this
is necessary to actually add the record to the end of the file.

</p><p><b>Displaying the current record</b>
<br>When a record containing a particular string has been found by
FIND it becomes the current record. DISP with -1 as the first
parameter, displays it.

</p><p>In the procedure alter:, VIEW is used to display just the first field of
the record, while you decide whether to edit it. If you choose to, each
field is then displayed by the EDIT function, which allows you to
alter what is on the screen.


<a name="8-15a"></a></p><p><font size="3"><b>7 Telephone logging (data file handling)</b></font>

</p><p>These 3 procedures make up a program which allows you to log telephone
calls. It stores their duration with your comments in a data file. It could
easily be adapted to record the duration of any other activity.

</p><p>The first procedure displays a menu like this with a phone UDG and the
clock. Because the clock uses UDGs 3, 4, 5, 6, 7 and 1, UDGs 0 and 2 been
used for the phone and the underline:

<table><tbody><tr><td bgcolor="silver"><font face="Courier">
X&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11:19a<br>
Logcall&nbsp;&nbsp;&nbsp;Viewcalls<br>
<br>
&nbsp;
</font></td></tr></tbody></table>


</p><pre><font face="Courier">logger:
LOCAL m%
UDG 0,31,21,14,10,31,31,0,31
UDG 2,0,0,0,0,0,0,0,31
PRINT CHR$(0);REPT$(CHR$(2),14)
CLOCK(1)
m%=MENUN(2,"Logcall,Viewcalls")
IF m%=0
  RETURN
ELSEIF m%=1
  logcall:
ELSE m%=2
  viewcall:
ENDIF

logcall:
LOCAL k%,h%,m%,s%,sec%,start$(8),swof%
ESCAPE OFF
IF NOT EXIST("A:LOG")
 CREATE "A:LOG",B,date$,t$,comment$
ELSE
 OPEN "A:LOG",B,date$,t$,comment$
ENDIF
swof%=PEEKB($7C)
POKEB $007C,0 :REM no auto turn off
B.t$="00:00:00"
B.date$=DATIM$
start$=RIGHT$(DATIM$,8)
h%=0 :m%=0 :s%=0 :sec%=SECOND
DO
 IF sec%&lt;&gt;SECOND
  BEEP 1,100
  sec%=SECOND :s%=s%+1
  IF s%=60 :s%=0 :m%=m%+1
   IF m%=60 :m%=0 :h%=h%+1
   ENDIF
  ENDIF
  B.t$=REPT$("0",-(h%&lt;10))+NUM$(h%,2)+":"
  B.t$=B.t$+REPT$("0",-(M%&lt;10))+NUM$(m%,2)+
  B.t$=B.t$+REPT$("0",-(s%&lt;10))+NUM$(s%,2)
 ENDIF
 AT 1,1 :PRINT "Started:";start$
 PRINT "Time:";B.t$
 PAUSE -1 :REM save battery
 k%=KEY
 IF k%=1
  GOTO exit::
 ENDIF
UNTIL k%=13
PRINT "Comments "+CHR$(63)
TRAP INPUT B.comment$
IF ERR=206
 GOTO exit::
ENDIF
CLS :PRINT "Saving" :APPEND
exit::
CLOSE
POKEB $007C,swof% :REM restore auto turn off
ESCAPE ON

viewcall:
LOCAL k%
TRAP OPEN "A:LOG",B,date$,t$,comment$
IF ERR :RETURN :ENDIF
DO
 k%=DISP (-1,"")
 NEXT
 IF k%=1
  RETURN
 ENDIF
UNTIL EOF
AT 1,4 :PRINT "  NO MORE ENTRIES"
PAUSE 25
RETURN</font></pre>

<p><b>Variables</b>
<br><b>k%</b> is used for the keypresses read by KEY.
<br><b>sec%</b> is the actual number of seconds past the minute at the start of
the procedure.
<br><b>s%</b> is the seconds shown counting up.
<br><b>m%</b> is the minutes shown counting up.
<br><b>h%</b> is the minutes shown counting up.
<br><b>start$</b> is the time the call started.
<br><b>swof$</b> is the initial setting of auto-switch off.

</p><p><b>The data file</b>
<br>A data file called LOG is created on device A: with three fields in each
record: one for the date, one for the time which the call took, and one for
your comments. When you run the program and log a call the date, time and
comment are appended to the data file as a record. Select Viewcalls to look
through all the appended records.
<br>You could also open the file A LOG in Xfiles, and search for the records
using Find.

</p><p><b>How the stopwatch counts up the elapsed time</b>
<br>The actual number of seconds past the minute is read from the system clock
by the SECOND function and assigned to sec% at the start. Then the SECOND
function is used again, and if it is no longer equal to sec% - i.e. when a
second has elapsed - 1 is added to s% and sec% is assigned the actual number
of seconds again. Whenever s% is 60, it is reset to 0 and 1 is added to m%
and so on.

</p><p><b>ESCAPE OFF</b>
<br>Normally <b>ON/CLEAR</b> pauses the execution of a procedure so that <b>Q</b> can be
pressed to quit. At the start of this procedure ESCAPE OFF is used. This
means that <b>ON/CLEAR</b> does not pause the program, and can thus be read by
the KEY and DISP functions and cause a RETURN to the PROG menu instead of
an ESCAPE error.

</p><p><b>Displaying the records</b>
<br>When A:LOG is opened in viewcall, the first record is made current then
displayed by DISP with - 1 as the first parameter. Then NEXT is used to
make each record current in turn.


<a name="8-19a"></a></p><p><font size="3"><b>8 Diary file handling procedure</b></font>

</p><p>If you save your diary to a file, you can use this program to copy all
the birthdays from one year to the next year. It could easily be
adapted to deal with other annual entries too.

</p><p>A saved diary file called "olddia" is opened. All the records
containing 1989 and birthday have the 1989 changed to 1990 and are put into a
file called "newdia". You can then restore "newdia" into
your current diary and merge the two.

</p><p>Remember to substitute the name of your saved diary for "olddia"
when you type the procedure in.

</p><pre><font face="Courier">birthday:
CREATE "a:newdia",B,date$,text$
OPEN "a:olddia",A,date$,text$
WHILE FINDW("1989*birthday")
 PRINT a.text$
 b.date$="1990"+mid$(a.date$,5,255)
 b.text$=a.text$
 USE B :APPEND
 USE A :NEXT
ENDWH
GET</font></pre>

</font><p><font face="Arial" size="2"><b>Diary files</b>
<br>A saved diary file is just like any other data file. However, for
more information about the format of records in diary files, see
Chapter 6.

</font>

</p><p align="center"><img src="./Psion Organiser II LZ_LZ64 Programming Manual_ Chapter 3-8_files/psibar.gif" width="312" height="24" alt="Psion bar."></p>

<div align="center"><center>
<table border="0" cellpadding="0" cellspacing="0" width="100%">
  <tbody><tr>
    <td width="100%" colspan="5" align="center" height="25"><font size="2" face="Arial">These
    pages should be viewed using Netscape 4.03 or Microsoft Internet Explorer 3.02 at 800x600
    pixels.</font></td>
  </tr>
  <tr>
    <td width="50" bgcolor="#FFFF00"><img src="./Psion Organiser II LZ_LZ64 Programming Manual_ Chapter 3-8_files/arrow_l.gif" align="middle" width="50" height="33" alt="Left arrow"></td>
    <td width="33%" bgcolor="#FFFF00"><a href="https://web.archive.org/web/20071228050654/http://members.surfeu.at/org2/manlzpg1.htm"><font face="Arial"><em><strong>LZ Prog. Manual Chpt. 1-2</strong></em></font></a></td>
        <td align="center" width="33%" bgcolor="#FFFF00"><a href="https://web.archive.org/web/20071228050654/http://members.surfeu.at/org2/org2.htm"><font face="Arial"><em><strong>~ 
          Homepage ~</strong></em></font></a></td>
    <td align="right" width="33%" bgcolor="#FFFF00"><font face="Arial"><em><strong><a href="https://web.archive.org/web/20071228050654/http://members.surfeu.at/org2/manlzpg3.htm">LZ Prog. Manual Chpt. 9</a></strong></em></font></td>
    <td align="right" width="50" bgcolor="#FFFF00"><img src="./Psion Organiser II LZ_LZ64 Programming Manual_ Chapter 3-8_files/arrow_r.gif" align="absmiddle" width="50" height="33" alt="Right arrow"></td>
  </tr>
</tbody></table>
</center></div>



</body></html>